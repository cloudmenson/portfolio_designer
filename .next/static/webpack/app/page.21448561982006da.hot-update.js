"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/shared/ui/prisma-background/index.tsx":
/*!***************************************************!*\
  !*** ./src/shared/ui/prisma-background/index.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Prism: () => (/* binding */ Prism)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Prism = (param)=>{\n    let { glow = 1, bloom = 0.5, noise = 11, scale = 3.6, height = 3.5, hueShift = 0, inertia = 0.05, baseWidth = 5.5, timeScale = 0.5, hoverStrength = 2, transparent = true, colorFrequency = 1, offset = {\n        x: 0,\n        y: 0\n    }, animationType = \"rotate\", suspendWhenOffscreen = false } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Prism.useEffect\": ()=>{\n            const container = containerRef.current;\n            if (!container) return;\n            const H = Math.max(0.001, height);\n            const BW = Math.max(0.001, baseWidth);\n            const BASE_HALF = BW * 0.5;\n            const GLOW = Math.max(0.0, glow);\n            const NOISE = Math.max(0.0, noise);\n            var _offset_x;\n            const offX = (_offset_x = offset === null || offset === void 0 ? void 0 : offset.x) !== null && _offset_x !== void 0 ? _offset_x : 0;\n            var _offset_y;\n            const offY = (_offset_y = offset === null || offset === void 0 ? void 0 : offset.y) !== null && _offset_y !== void 0 ? _offset_y : 0;\n            const SAT = transparent ? 1.5 : 1;\n            const SCALE = Math.max(0.001, scale);\n            const HUE = hueShift || 0;\n            const CFREQ = Math.max(0.0, colorFrequency || 1);\n            const BLOOM = Math.max(0.0, bloom || 1);\n            const RSX = 1;\n            const RSY = 1;\n            const RSZ = 1;\n            const TS = Math.max(0, timeScale || 1);\n            const HOVSTR = Math.max(0, hoverStrength || 1);\n            const INERT = Math.max(0, Math.min(1, inertia || 0.12));\n            const dpr = Math.min(2, window.devicePixelRatio || 1);\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_2__.Renderer({\n                dpr,\n                alpha: transparent,\n                antialias: false\n            });\n            const gl = renderer.gl;\n            gl.disable(gl.DEPTH_TEST);\n            gl.disable(gl.CULL_FACE);\n            gl.disable(gl.BLEND);\n            Object.assign(gl.canvas.style, {\n                position: \"absolute\",\n                inset: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                display: \"block\"\n            });\n            container.appendChild(gl.canvas);\n            const vertex = \"\\n      attribute vec2 position;\\n      void main() {\\n        gl_Position = vec4(position, 0.0, 1.0);\\n      }\\n    \";\n            const fragment = \"\\n      precision highp float;\\n\\n      uniform vec2  iResolution;\\n      uniform float iTime;\\n\\n      uniform float uHeight;\\n      uniform float uBaseHalf;\\n      uniform mat3  uRot;\\n      uniform int   uUseBaseWobble;\\n      uniform float uGlow;\\n      uniform vec2  uOffsetPx;\\n      uniform float uNoise;\\n      uniform float uSaturation;\\n      uniform float uScale;\\n      uniform float uHueShift;\\n      uniform float uColorFreq;\\n      uniform float uBloom;\\n      uniform float uCenterShift;\\n      uniform float uInvBaseHalf;\\n      uniform float uInvHeight;\\n      uniform float uMinAxis;\\n      uniform float uPxScale;\\n      uniform float uTimeScale;\\n\\n      vec4 tanh4(vec4 x){\\n        vec4 e2x = exp(2.0*x);\\n        return (e2x - 1.0) / (e2x + 1.0);\\n      }\\n\\n      float rand(vec2 co){\\n        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\\n      }\\n\\n      float sdOctaAnisoInv(vec3 p){\\n        vec3 q = vec3(abs(p.x) * uInvBaseHalf, abs(p.y) * uInvHeight, abs(p.z) * uInvBaseHalf);\\n        float m = q.x + q.y + q.z - 1.0;\\n        return m * uMinAxis * 0.5773502691896258;\\n      }\\n\\n      float sdPyramidUpInv(vec3 p){\\n        float oct = sdOctaAnisoInv(p);\\n        float halfSpace = -p.y;\\n        return max(oct, halfSpace);\\n      }\\n\\n      mat3 hueRotation(float a){\\n        float c = cos(a), s = sin(a);\\n        mat3 W = mat3(\\n          0.299, 0.587, 0.114,\\n          0.299, 0.587, 0.114,\\n          0.299, 0.587, 0.114\\n        );\\n        mat3 U = mat3(\\n           0.701, -0.587, -0.114,\\n          -0.299,  0.413, -0.114,\\n          -0.300, -0.588,  0.886\\n        );\\n        mat3 V = mat3(\\n           0.168, -0.331,  0.500,\\n           0.328,  0.035, -0.500,\\n          -0.497,  0.296,  0.201\\n        );\\n        return W + U * c + V * s;\\n      }\\n\\n      void main(){\\n        vec2 f = (gl_FragCoord.xy - 0.5 * iResolution.xy - uOffsetPx) * uPxScale;\\n\\n        float z = 5.0;\\n        float d = 0.0;\\n\\n        vec3 p;\\n        vec4 o = vec4(0.0);\\n\\n        float centerShift = uCenterShift;\\n        float cf = uColorFreq;\\n\\n        mat2 wob = mat2(1.0);\\n        if (uUseBaseWobble == 1) {\\n          float t = iTime * uTimeScale;\\n          float c0 = cos(t + 0.0);\\n          float c1 = cos(t + 33.0);\\n          float c2 = cos(t + 11.0);\\n          wob = mat2(c0, c1, c2, c0);\\n        }\\n\\n        const int STEPS = 100;\\n        for (int i = 0; i < STEPS; i++) {\\n          p = vec3(f, z);\\n          p.xz = p.xz * wob;\\n          p = uRot * p;\\n          vec3 q = p;\\n          q.y += centerShift;\\n          d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));\\n          z -= d;\\n          o += (sin((p.y + z) * cf + vec4(0.0, 1.0, 2.0, 3.0)) + 1.0) / d;\\n        }\\n\\n        o = tanh4(o * o * (uGlow * uBloom) / 1e5);\\n\\n        vec3 col = o.rgb;\\n        float n = rand(gl_FragCoord.xy + vec2(iTime));\\n        col += (n - 0.5) * uNoise;\\n        col = clamp(col, 0.0, 1.0);\\n\\n        float L = dot(col, vec3(0.2126, 0.7152, 0.0722));\\n        col = clamp(mix(vec3(L), col, uSaturation), 0.0, 1.0);\\n\\n        if(abs(uHueShift) > 0.0001){\\n          col = clamp(hueRotation(uHueShift) * col, 0.0, 1.0);\\n        }\\n\\n        gl_FragColor = vec4(col, o.a);\\n      }\\n    \";\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_3__.Triangle(gl);\n            const iResBuf = new Float32Array(2);\n            const offsetPxBuf = new Float32Array(2);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_4__.Program(gl, {\n                vertex,\n                fragment,\n                uniforms: {\n                    iResolution: {\n                        value: iResBuf\n                    },\n                    iTime: {\n                        value: 0\n                    },\n                    uHeight: {\n                        value: H\n                    },\n                    uBaseHalf: {\n                        value: BASE_HALF\n                    },\n                    uUseBaseWobble: {\n                        value: 1\n                    },\n                    uRot: {\n                        value: new Float32Array([\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1\n                        ])\n                    },\n                    uGlow: {\n                        value: GLOW\n                    },\n                    uOffsetPx: {\n                        value: offsetPxBuf\n                    },\n                    uNoise: {\n                        value: NOISE\n                    },\n                    uSaturation: {\n                        value: SAT\n                    },\n                    uScale: {\n                        value: SCALE\n                    },\n                    uHueShift: {\n                        value: HUE\n                    },\n                    uColorFreq: {\n                        value: CFREQ\n                    },\n                    uBloom: {\n                        value: BLOOM\n                    },\n                    uCenterShift: {\n                        value: H * 0.25\n                    },\n                    uInvBaseHalf: {\n                        value: 1 / BASE_HALF\n                    },\n                    uInvHeight: {\n                        value: 1 / H\n                    },\n                    uMinAxis: {\n                        value: Math.min(BASE_HALF, H)\n                    },\n                    uPxScale: {\n                        value: 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE)\n                    },\n                    uTimeScale: {\n                        value: TS\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_5__.Mesh(gl, {\n                geometry,\n                program\n            });\n            const resize = {\n                \"Prism.useEffect.resize\": ()=>{\n                    const w = container.clientWidth || 1;\n                    const h = container.clientHeight || 1;\n                    renderer.setSize(w, h);\n                    iResBuf[0] = gl.drawingBufferWidth;\n                    iResBuf[1] = gl.drawingBufferHeight;\n                    offsetPxBuf[0] = offX * dpr;\n                    offsetPxBuf[1] = offY * dpr;\n                    program.uniforms.uPxScale.value = 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE);\n                }\n            }[\"Prism.useEffect.resize\"];\n            const ro = new ResizeObserver(resize);\n            ro.observe(container);\n            resize();\n            const rotBuf = new Float32Array(9);\n            const setMat3FromEuler = {\n                \"Prism.useEffect.setMat3FromEuler\": (yawY, pitchX, rollZ, out)=>{\n                    const cy = Math.cos(yawY), sy = Math.sin(yawY);\n                    const cx = Math.cos(pitchX), sx = Math.sin(pitchX);\n                    const cz = Math.cos(rollZ), sz = Math.sin(rollZ);\n                    const r00 = cy * cz + sy * sx * sz;\n                    const r01 = -cy * sz + sy * sx * cz;\n                    const r02 = sy * cx;\n                    const r10 = cx * sz;\n                    const r11 = cx * cz;\n                    const r12 = -sx;\n                    const r20 = -sy * cz + cy * sx * sz;\n                    const r21 = sy * sz + cy * sx * cz;\n                    const r22 = cy * cx;\n                    out[0] = r00;\n                    out[1] = r10;\n                    out[2] = r20;\n                    out[3] = r01;\n                    out[4] = r11;\n                    out[5] = r21;\n                    out[6] = r02;\n                    out[7] = r12;\n                    out[8] = r22;\n                    return out;\n                }\n            }[\"Prism.useEffect.setMat3FromEuler\"];\n            const NOISE_IS_ZERO = NOISE < 1e-6;\n            let raf = 0;\n            const t0 = performance.now();\n            const startRAF = {\n                \"Prism.useEffect.startRAF\": ()=>{\n                    if (raf) return;\n                    raf = requestAnimationFrame(render);\n                }\n            }[\"Prism.useEffect.startRAF\"];\n            const stopRAF = {\n                \"Prism.useEffect.stopRAF\": ()=>{\n                    if (!raf) return;\n                    cancelAnimationFrame(raf);\n                    raf = 0;\n                }\n            }[\"Prism.useEffect.stopRAF\"];\n            const rnd = {\n                \"Prism.useEffect.rnd\": ()=>Math.random()\n            }[\"Prism.useEffect.rnd\"];\n            const wX = (0.3 + rnd() * 0.6) * RSX;\n            const wY = (0.2 + rnd() * 0.7) * RSY;\n            const wZ = (0.1 + rnd() * 0.5) * RSZ;\n            const phX = rnd() * Math.PI * 2;\n            const phZ = rnd() * Math.PI * 2;\n            let yaw = 0, pitch = 0, roll = 0;\n            let targetYaw = 0, targetPitch = 0;\n            const lerp = {\n                \"Prism.useEffect.lerp\": (a, b, t)=>a + (b - a) * t\n            }[\"Prism.useEffect.lerp\"];\n            const pointer = {\n                x: 0,\n                y: 0,\n                inside: true\n            };\n            const onMove = {\n                \"Prism.useEffect.onMove\": (e)=>{\n                    const ww = Math.max(1, window.innerWidth);\n                    const wh = Math.max(1, window.innerHeight);\n                    const cx = ww * 0.5;\n                    const cy = wh * 0.5;\n                    const nx = (e.clientX - cx) / (ww * 0.5);\n                    const ny = (e.clientY - cy) / (wh * 0.5);\n                    pointer.x = Math.max(-1, Math.min(1, nx));\n                    pointer.y = Math.max(-1, Math.min(1, ny));\n                    pointer.inside = true;\n                }\n            }[\"Prism.useEffect.onMove\"];\n            const onLeave = {\n                \"Prism.useEffect.onLeave\": ()=>{\n                    pointer.inside = false;\n                }\n            }[\"Prism.useEffect.onLeave\"];\n            const onBlur = {\n                \"Prism.useEffect.onBlur\": ()=>{\n                    pointer.inside = false;\n                }\n            }[\"Prism.useEffect.onBlur\"];\n            let onPointerMove = null;\n            if (animationType === \"hover\") {\n                onPointerMove = ({\n                    \"Prism.useEffect\": (e)=>{\n                        onMove(e);\n                        startRAF();\n                    }\n                })[\"Prism.useEffect\"];\n                window.addEventListener(\"pointermove\", onPointerMove, {\n                    passive: true\n                });\n                window.addEventListener(\"mouseleave\", onLeave);\n                window.addEventListener(\"blur\", onBlur);\n                program.uniforms.uUseBaseWobble.value = 0;\n            } else if (animationType === \"3drotate\") {\n                program.uniforms.uUseBaseWobble.value = 0;\n            } else {\n                program.uniforms.uUseBaseWobble.value = 1;\n            }\n            const render = {\n                \"Prism.useEffect.render\": (t)=>{\n                    const time = (t - t0) * 0.001;\n                    program.uniforms.iTime.value = time;\n                    let continueRAF = true;\n                    if (animationType === \"hover\") {\n                        const maxPitch = 0.6 * HOVSTR;\n                        const maxYaw = 0.6 * HOVSTR;\n                        targetYaw = (pointer.inside ? -pointer.x : 0) * maxYaw;\n                        targetPitch = (pointer.inside ? pointer.y : 0) * maxPitch;\n                        const prevYaw = yaw;\n                        const prevPitch = pitch;\n                        const prevRoll = roll;\n                        yaw = lerp(prevYaw, targetYaw, INERT);\n                        pitch = lerp(prevPitch, targetPitch, INERT);\n                        roll = lerp(prevRoll, 0, 0.1);\n                        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n                        if (NOISE_IS_ZERO) {\n                            const settled = Math.abs(yaw - targetYaw) < 1e-4 && Math.abs(pitch - targetPitch) < 1e-4 && Math.abs(roll) < 1e-4;\n                            if (settled) continueRAF = false;\n                        }\n                    } else if (animationType === \"3drotate\") {\n                        const tScaled = time * TS;\n                        yaw = tScaled * wY;\n                        pitch = Math.sin(tScaled * wX + phX) * 0.6;\n                        roll = Math.sin(tScaled * wZ + phZ) * 0.5;\n                        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n                        if (TS < 1e-6) continueRAF = false;\n                    } else {\n                        rotBuf[0] = 1;\n                        rotBuf[1] = 0;\n                        rotBuf[2] = 0;\n                        rotBuf[3] = 0;\n                        rotBuf[4] = 1;\n                        rotBuf[5] = 0;\n                        rotBuf[6] = 0;\n                        rotBuf[7] = 0;\n                        rotBuf[8] = 1;\n                        program.uniforms.uRot.value = rotBuf;\n                        if (TS < 1e-6) continueRAF = false;\n                    }\n                    renderer.render({\n                        scene: mesh\n                    });\n                    if (continueRAF) {\n                        raf = requestAnimationFrame(render);\n                    } else {\n                        raf = 0;\n                    }\n                }\n            }[\"Prism.useEffect.render\"];\n            if (suspendWhenOffscreen) {\n                const io = new IntersectionObserver({\n                    \"Prism.useEffect\": (entries)=>{\n                        const vis = entries.some({\n                            \"Prism.useEffect.vis\": (e)=>e.isIntersecting\n                        }[\"Prism.useEffect.vis\"]);\n                        if (vis) startRAF();\n                        else stopRAF();\n                    }\n                }[\"Prism.useEffect\"]);\n                io.observe(container);\n                startRAF();\n                container.__prismIO = io;\n            } else {\n                startRAF();\n            }\n            return ({\n                \"Prism.useEffect\": ()=>{\n                    stopRAF();\n                    ro.disconnect();\n                    if (animationType === \"hover\") {\n                        if (onPointerMove) window.removeEventListener(\"pointermove\", onPointerMove);\n                        window.removeEventListener(\"mouseleave\", onLeave);\n                        window.removeEventListener(\"blur\", onBlur);\n                    }\n                    if (suspendWhenOffscreen) {\n                        const io = container.__prismIO;\n                        if (io) io.disconnect();\n                        delete container.__prismIO;\n                    }\n                    if (gl.canvas.parentElement === container) container.removeChild(gl.canvas);\n                }\n            })[\"Prism.useEffect\"];\n        }\n    }[\"Prism.useEffect\"], [\n        glow,\n        noise,\n        scale,\n        bloom,\n        height,\n        inertia,\n        hueShift,\n        baseWidth,\n        offset === null || offset === void 0 ? void 0 : offset.x,\n        offset === null || offset === void 0 ? void 0 : offset.y,\n        timeScale,\n        transparent,\n        animationType,\n        hoverStrength,\n        colorFrequency,\n        suspendWhenOffscreen\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full absolute\",\n        ref: containerRef\n    }, void 0, false, {\n        fileName: \"/Users/cloudmenson/Desktop/Files/Programming/My portfolio website/designer-portfolio/src/shared/ui/prisma-background/index.tsx\",\n        lineNumber: 479,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Prism, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = Prism;\nvar _c;\n$RefreshReg$(_c, \"Prism\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvdWkvcHJpc21hLWJhY2tncm91bmQvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTztBQW9CakQsTUFBTU8sUUFBOEI7UUFBQyxFQUMxQ0MsT0FBTyxDQUFDLEVBQ1JDLFFBQVEsR0FBRyxFQUNYQyxRQUFRLEVBQUUsRUFDVkMsUUFBUSxHQUFHLEVBQ1hDLFNBQVMsR0FBRyxFQUNaQyxXQUFXLENBQUMsRUFDWkMsVUFBVSxJQUFJLEVBQ2RDLFlBQVksR0FBRyxFQUNmQyxZQUFZLEdBQUcsRUFDZkMsZ0JBQWdCLENBQUMsRUFDakJDLGNBQWMsSUFBSSxFQUNsQkMsaUJBQWlCLENBQUMsRUFDbEJDLFNBQVM7UUFBRUMsR0FBRztRQUFHQyxHQUFHO0lBQUUsQ0FBQyxFQUN2QkMsZ0JBQWdCLFFBQVEsRUFDeEJDLHVCQUF1QixLQUFLLEVBQzdCOztJQUNDLE1BQU1DLGVBQWV2Qiw2Q0FBTUEsQ0FBd0I7SUFFbkRELGdEQUFTQTsyQkFBQztZQUNSLE1BQU15QixZQUFZRCxhQUFhRSxPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsV0FBVztZQUVoQixNQUFNRSxJQUFJQyxLQUFLQyxHQUFHLENBQUMsT0FBT2xCO1lBQzFCLE1BQU1tQixLQUFLRixLQUFLQyxHQUFHLENBQUMsT0FBT2Y7WUFDM0IsTUFBTWlCLFlBQVlELEtBQUs7WUFDdkIsTUFBTUUsT0FBT0osS0FBS0MsR0FBRyxDQUFDLEtBQUt0QjtZQUMzQixNQUFNMEIsUUFBUUwsS0FBS0MsR0FBRyxDQUFDLEtBQUtwQjtnQkFDZlU7WUFBYixNQUFNZSxPQUFPZixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFDLENBQUMsY0FBVEQsdUJBQUFBLFlBQWE7Z0JBQ2JBO1lBQWIsTUFBTWdCLE9BQU9oQixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFFLENBQUMsY0FBVEYsdUJBQUFBLFlBQWE7WUFDMUIsTUFBTWlCLE1B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O1FBQ0FFO1FBQ0FLO0tBQ0Q7SUFFRCxxQkFBTyw4REFBQytLO1FBQUlDLFdBQVU7UUFBeUJDLEtBQUtoTDs7Ozs7O0FBQ3RELEVBQUU7R0ExY1dsQjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2Nsb3VkbWVuc29uL0Rlc2t0b3AvRmlsZXMvUHJvZ3JhbW1pbmcvTXkgcG9ydGZvbGlvIHdlYnNpdGUvZGVzaWduZXItcG9ydGZvbGlvL3NyYy9zaGFyZWQvdWkvcHJpc21hLWJhY2tncm91bmQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTWVzaCwgUHJvZ3JhbSwgUmVuZGVyZXIsIFRyaWFuZ2xlIH0gZnJvbSBcIm9nbFwiO1xuXG50eXBlIFByaXNtUHJvcHMgPSB7XG4gIGdsb3c/OiBudW1iZXI7XG4gIG5vaXNlPzogbnVtYmVyO1xuICBzY2FsZT86IG51bWJlcjtcbiAgYmxvb20/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgaW5lcnRpYT86IG51bWJlcjtcbiAgaHVlU2hpZnQ/OiBudW1iZXI7XG4gIGJhc2VXaWR0aD86IG51bWJlcjtcbiAgdGltZVNjYWxlPzogbnVtYmVyO1xuICB0cmFuc3BhcmVudD86IGJvb2xlYW47XG4gIGhvdmVyU3RyZW5ndGg/OiBudW1iZXI7XG4gIGNvbG9yRnJlcXVlbmN5PzogbnVtYmVyO1xuICBzdXNwZW5kV2hlbk9mZnNjcmVlbj86IGJvb2xlYW47XG4gIG9mZnNldD86IHsgeD86IG51bWJlcjsgeT86IG51bWJlciB9O1xuICBhbmltYXRpb25UeXBlPzogXCJyb3RhdGVcIiB8IFwiaG92ZXJcIiB8IFwiM2Ryb3RhdGVcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBQcmlzbTogUmVhY3QuRkM8UHJpc21Qcm9wcz4gPSAoe1xuICBnbG93ID0gMSxcbiAgYmxvb20gPSAwLjUsXG4gIG5vaXNlID0gMTEsXG4gIHNjYWxlID0gMy42LFxuICBoZWlnaHQgPSAzLjUsXG4gIGh1ZVNoaWZ0ID0gMCxcbiAgaW5lcnRpYSA9IDAuMDUsXG4gIGJhc2VXaWR0aCA9IDUuNSxcbiAgdGltZVNjYWxlID0gMC41LFxuICBob3ZlclN0cmVuZ3RoID0gMixcbiAgdHJhbnNwYXJlbnQgPSB0cnVlLFxuICBjb2xvckZyZXF1ZW5jeSA9IDEsXG4gIG9mZnNldCA9IHsgeDogMCwgeTogMCB9LFxuICBhbmltYXRpb25UeXBlID0gXCJyb3RhdGVcIixcbiAgc3VzcGVuZFdoZW5PZmZzY3JlZW4gPSBmYWxzZSxcbn0pID0+IHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgY29uc3QgSCA9IE1hdGgubWF4KDAuMDAxLCBoZWlnaHQpO1xuICAgIGNvbnN0IEJXID0gTWF0aC5tYXgoMC4wMDEsIGJhc2VXaWR0aCk7XG4gICAgY29uc3QgQkFTRV9IQUxGID0gQlcgKiAwLjU7XG4gICAgY29uc3QgR0xPVyA9IE1hdGgubWF4KDAuMCwgZ2xvdyk7XG4gICAgY29uc3QgTk9JU0UgPSBNYXRoLm1heCgwLjAsIG5vaXNlKTtcbiAgICBjb25zdCBvZmZYID0gb2Zmc2V0Py54ID8/IDA7XG4gICAgY29uc3Qgb2ZmWSA9IG9mZnNldD8ueSA/PyAwO1xuICAgIGNvbnN0IFNBVCA9IHRyYW5zcGFyZW50ID8gMS41IDogMTtcbiAgICBjb25zdCBTQ0FMRSA9IE1hdGgubWF4KDAuMDAxLCBzY2FsZSk7XG4gICAgY29uc3QgSFVFID0gaHVlU2hpZnQgfHwgMDtcbiAgICBjb25zdCBDRlJFUSA9IE1hdGgubWF4KDAuMCwgY29sb3JGcmVxdWVuY3kgfHwgMSk7XG4gICAgY29uc3QgQkxPT00gPSBNYXRoLm1heCgwLjAsIGJsb29tIHx8IDEpO1xuICAgIGNvbnN0IFJTWCA9IDE7XG4gICAgY29uc3QgUlNZID0gMTtcbiAgICBjb25zdCBSU1ogPSAxO1xuICAgIGNvbnN0IFRTID0gTWF0aC5tYXgoMCwgdGltZVNjYWxlIHx8IDEpO1xuICAgIGNvbnN0IEhPVlNUUiA9IE1hdGgubWF4KDAsIGhvdmVyU3RyZW5ndGggfHwgMSk7XG4gICAgY29uc3QgSU5FUlQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBpbmVydGlhIHx8IDAuMTIpKTtcblxuICAgIGNvbnN0IGRwciA9IE1hdGgubWluKDIsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHtcbiAgICAgIGRwcixcbiAgICAgIGFscGhhOiB0cmFuc3BhcmVudCxcbiAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgfSk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgIE9iamVjdC5hc3NpZ24oZ2wuY2FudmFzLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgaW5zZXQ6IFwiMFwiLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICB9IGFzIFBhcnRpYWw8Q1NTU3R5bGVEZWNsYXJhdGlvbj4pO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnbC5jYW52YXMpO1xuXG4gICAgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqLyBgXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IGZyYWdtZW50ID0gLyogZ2xzbCAqLyBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICAgIHVuaWZvcm0gdmVjMiAgaVJlc29sdXRpb247XG4gICAgICB1bmlmb3JtIGZsb2F0IGlUaW1lO1xuXG4gICAgICB1bmlmb3JtIGZsb2F0IHVIZWlnaHQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVCYXNlSGFsZjtcbiAgICAgIHVuaWZvcm0gbWF0MyAgdVJvdDtcbiAgICAgIHVuaWZvcm0gaW50ICAgdVVzZUJhc2VXb2JibGU7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVHbG93O1xuICAgICAgdW5pZm9ybSB2ZWMyICB1T2Zmc2V0UHg7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVOb2lzZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdVNhdHVyYXRpb247XG4gICAgICB1bmlmb3JtIGZsb2F0IHVTY2FsZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUh1ZVNoaWZ0O1xuICAgICAgdW5pZm9ybSBmbG9hdCB1Q29sb3JGcmVxO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1Qmxvb207XG4gICAgICB1bmlmb3JtIGZsb2F0IHVDZW50ZXJTaGlmdDtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUludkJhc2VIYWxmO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1SW52SGVpZ2h0O1xuICAgICAgdW5pZm9ybSBmbG9hdCB1TWluQXhpcztcbiAgICAgIHVuaWZvcm0gZmxvYXQgdVB4U2NhbGU7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVUaW1lU2NhbGU7XG5cbiAgICAgIHZlYzQgdGFuaDQodmVjNCB4KXtcbiAgICAgICAgdmVjNCBlMnggPSBleHAoMi4wKngpO1xuICAgICAgICByZXR1cm4gKGUyeCAtIDEuMCkgLyAoZTJ4ICsgMS4wKTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgcmFuZCh2ZWMyIGNvKXtcbiAgICAgICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28sIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1MzEyMyk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHNkT2N0YUFuaXNvSW52KHZlYzMgcCl7XG4gICAgICAgIHZlYzMgcSA9IHZlYzMoYWJzKHAueCkgKiB1SW52QmFzZUhhbGYsIGFicyhwLnkpICogdUludkhlaWdodCwgYWJzKHAueikgKiB1SW52QmFzZUhhbGYpO1xuICAgICAgICBmbG9hdCBtID0gcS54ICsgcS55ICsgcS56IC0gMS4wO1xuICAgICAgICByZXR1cm4gbSAqIHVNaW5BeGlzICogMC41NzczNTAyNjkxODk2MjU4O1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBzZFB5cmFtaWRVcEludih2ZWMzIHApe1xuICAgICAgICBmbG9hdCBvY3QgPSBzZE9jdGFBbmlzb0ludihwKTtcbiAgICAgICAgZmxvYXQgaGFsZlNwYWNlID0gLXAueTtcbiAgICAgICAgcmV0dXJuIG1heChvY3QsIGhhbGZTcGFjZSk7XG4gICAgICB9XG5cbiAgICAgIG1hdDMgaHVlUm90YXRpb24oZmxvYXQgYSl7XG4gICAgICAgIGZsb2F0IGMgPSBjb3MoYSksIHMgPSBzaW4oYSk7XG4gICAgICAgIG1hdDMgVyA9IG1hdDMoXG4gICAgICAgICAgMC4yOTksIDAuNTg3LCAwLjExNCxcbiAgICAgICAgICAwLjI5OSwgMC41ODcsIDAuMTE0LFxuICAgICAgICAgIDAuMjk5LCAwLjU4NywgMC4xMTRcbiAgICAgICAgKTtcbiAgICAgICAgbWF0MyBVID0gbWF0MyhcbiAgICAgICAgICAgMC43MDEsIC0wLjU4NywgLTAuMTE0LFxuICAgICAgICAgIC0wLjI5OSwgIDAuNDEzLCAtMC4xMTQsXG4gICAgICAgICAgLTAuMzAwLCAtMC41ODgsICAwLjg4NlxuICAgICAgICApO1xuICAgICAgICBtYXQzIFYgPSBtYXQzKFxuICAgICAgICAgICAwLjE2OCwgLTAuMzMxLCAgMC41MDAsXG4gICAgICAgICAgIDAuMzI4LCAgMC4wMzUsIC0wLjUwMCxcbiAgICAgICAgICAtMC40OTcsICAwLjI5NiwgIDAuMjAxXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBXICsgVSAqIGMgKyBWICogcztcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCl7XG4gICAgICAgIHZlYzIgZiA9IChnbF9GcmFnQ29vcmQueHkgLSAwLjUgKiBpUmVzb2x1dGlvbi54eSAtIHVPZmZzZXRQeCkgKiB1UHhTY2FsZTtcblxuICAgICAgICBmbG9hdCB6ID0gNS4wO1xuICAgICAgICBmbG9hdCBkID0gMC4wO1xuXG4gICAgICAgIHZlYzMgcDtcbiAgICAgICAgdmVjNCBvID0gdmVjNCgwLjApO1xuXG4gICAgICAgIGZsb2F0IGNlbnRlclNoaWZ0ID0gdUNlbnRlclNoaWZ0O1xuICAgICAgICBmbG9hdCBjZiA9IHVDb2xvckZyZXE7XG5cbiAgICAgICAgbWF0MiB3b2IgPSBtYXQyKDEuMCk7XG4gICAgICAgIGlmICh1VXNlQmFzZVdvYmJsZSA9PSAxKSB7XG4gICAgICAgICAgZmxvYXQgdCA9IGlUaW1lICogdVRpbWVTY2FsZTtcbiAgICAgICAgICBmbG9hdCBjMCA9IGNvcyh0ICsgMC4wKTtcbiAgICAgICAgICBmbG9hdCBjMSA9IGNvcyh0ICsgMzMuMCk7XG4gICAgICAgICAgZmxvYXQgYzIgPSBjb3ModCArIDExLjApO1xuICAgICAgICAgIHdvYiA9IG1hdDIoYzAsIGMxLCBjMiwgYzApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW50IFNURVBTID0gMTAwO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNURVBTOyBpKyspIHtcbiAgICAgICAgICBwID0gdmVjMyhmLCB6KTtcbiAgICAgICAgICBwLnh6ID0gcC54eiAqIHdvYjtcbiAgICAgICAgICBwID0gdVJvdCAqIHA7XG4gICAgICAgICAgdmVjMyBxID0gcDtcbiAgICAgICAgICBxLnkgKz0gY2VudGVyU2hpZnQ7XG4gICAgICAgICAgZCA9IDAuMSArIDAuMiAqIGFicyhzZFB5cmFtaWRVcEludihxKSk7XG4gICAgICAgICAgeiAtPSBkO1xuICAgICAgICAgIG8gKz0gKHNpbigocC55ICsgeikgKiBjZiArIHZlYzQoMC4wLCAxLjAsIDIuMCwgMy4wKSkgKyAxLjApIC8gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIG8gPSB0YW5oNChvICogbyAqICh1R2xvdyAqIHVCbG9vbSkgLyAxZTUpO1xuXG4gICAgICAgIHZlYzMgY29sID0gby5yZ2I7XG4gICAgICAgIGZsb2F0IG4gPSByYW5kKGdsX0ZyYWdDb29yZC54eSArIHZlYzIoaVRpbWUpKTtcbiAgICAgICAgY29sICs9IChuIC0gMC41KSAqIHVOb2lzZTtcbiAgICAgICAgY29sID0gY2xhbXAoY29sLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgZmxvYXQgTCA9IGRvdChjb2wsIHZlYzMoMC4yMTI2LCAwLjcxNTIsIDAuMDcyMikpO1xuICAgICAgICBjb2wgPSBjbGFtcChtaXgodmVjMyhMKSwgY29sLCB1U2F0dXJhdGlvbiksIDAuMCwgMS4wKTtcblxuICAgICAgICBpZihhYnModUh1ZVNoaWZ0KSA+IDAuMDAwMSl7XG4gICAgICAgICAgY29sID0gY2xhbXAoaHVlUm90YXRpb24odUh1ZVNoaWZ0KSAqIGNvbCwgMC4wLCAxLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2wsIG8uYSk7XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRyaWFuZ2xlKGdsKTtcbiAgICBjb25zdCBpUmVzQnVmID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBjb25zdCBvZmZzZXRQeEJ1ZiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaVJlc29sdXRpb246IHsgdmFsdWU6IGlSZXNCdWYgfSxcbiAgICAgICAgaVRpbWU6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgdUhlaWdodDogeyB2YWx1ZTogSCB9LFxuICAgICAgICB1QmFzZUhhbGY6IHsgdmFsdWU6IEJBU0VfSEFMRiB9LFxuICAgICAgICB1VXNlQmFzZVdvYmJsZTogeyB2YWx1ZTogMSB9LFxuICAgICAgICB1Um90OiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXSkgfSxcbiAgICAgICAgdUdsb3c6IHsgdmFsdWU6IEdMT1cgfSxcbiAgICAgICAgdU9mZnNldFB4OiB7IHZhbHVlOiBvZmZzZXRQeEJ1ZiB9LFxuICAgICAgICB1Tm9pc2U6IHsgdmFsdWU6IE5PSVNFIH0sXG4gICAgICAgIHVTYXR1cmF0aW9uOiB7IHZhbHVlOiBTQVQgfSxcbiAgICAgICAgdVNjYWxlOiB7IHZhbHVlOiBTQ0FMRSB9LFxuICAgICAgICB1SHVlU2hpZnQ6IHsgdmFsdWU6IEhVRSB9LFxuICAgICAgICB1Q29sb3JGcmVxOiB7IHZhbHVlOiBDRlJFUSB9LFxuICAgICAgICB1Qmxvb206IHsgdmFsdWU6IEJMT09NIH0sXG4gICAgICAgIHVDZW50ZXJTaGlmdDogeyB2YWx1ZTogSCAqIDAuMjUgfSxcbiAgICAgICAgdUludkJhc2VIYWxmOiB7IHZhbHVlOiAxIC8gQkFTRV9IQUxGIH0sXG4gICAgICAgIHVJbnZIZWlnaHQ6IHsgdmFsdWU6IDEgLyBIIH0sXG4gICAgICAgIHVNaW5BeGlzOiB7IHZhbHVlOiBNYXRoLm1pbihCQVNFX0hBTEYsIEgpIH0sXG4gICAgICAgIHVQeFNjYWxlOiB7XG4gICAgICAgICAgdmFsdWU6IDEgLyAoKGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgfHwgMSkgKiAwLjEgKiBTQ0FMRSksXG4gICAgICAgIH0sXG4gICAgICAgIHVUaW1lU2NhbGU6IHsgdmFsdWU6IFRTIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnbCwgeyBnZW9tZXRyeSwgcHJvZ3JhbSB9KTtcblxuICAgIGNvbnN0IHJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGggfHwgMTtcbiAgICAgIGNvbnN0IGggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDE7XG4gICAgICByZW5kZXJlci5zZXRTaXplKHcsIGgpO1xuICAgICAgaVJlc0J1ZlswXSA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcbiAgICAgIGlSZXNCdWZbMV0gPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgICAgb2Zmc2V0UHhCdWZbMF0gPSBvZmZYICogZHByO1xuICAgICAgb2Zmc2V0UHhCdWZbMV0gPSBvZmZZICogZHByO1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51UHhTY2FsZS52YWx1ZSA9XG4gICAgICAgIDEgLyAoKGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgfHwgMSkgKiAwLjEgKiBTQ0FMRSk7XG4gICAgfTtcbiAgICBjb25zdCBybyA9IG5ldyBSZXNpemVPYnNlcnZlcihyZXNpemUpO1xuICAgIHJvLm9ic2VydmUoY29udGFpbmVyKTtcbiAgICByZXNpemUoKTtcblxuICAgIGNvbnN0IHJvdEJ1ZiA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgY29uc3Qgc2V0TWF0M0Zyb21FdWxlciA9IChcbiAgICAgIHlhd1k6IG51bWJlcixcbiAgICAgIHBpdGNoWDogbnVtYmVyLFxuICAgICAgcm9sbFo6IG51bWJlcixcbiAgICAgIG91dDogRmxvYXQzMkFycmF5XG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBjeSA9IE1hdGguY29zKHlhd1kpLFxuICAgICAgICBzeSA9IE1hdGguc2luKHlhd1kpO1xuICAgICAgY29uc3QgY3ggPSBNYXRoLmNvcyhwaXRjaFgpLFxuICAgICAgICBzeCA9IE1hdGguc2luKHBpdGNoWCk7XG4gICAgICBjb25zdCBjeiA9IE1hdGguY29zKHJvbGxaKSxcbiAgICAgICAgc3ogPSBNYXRoLnNpbihyb2xsWik7XG4gICAgICBjb25zdCByMDAgPSBjeSAqIGN6ICsgc3kgKiBzeCAqIHN6O1xuICAgICAgY29uc3QgcjAxID0gLWN5ICogc3ogKyBzeSAqIHN4ICogY3o7XG4gICAgICBjb25zdCByMDIgPSBzeSAqIGN4O1xuXG4gICAgICBjb25zdCByMTAgPSBjeCAqIHN6O1xuICAgICAgY29uc3QgcjExID0gY3ggKiBjejtcbiAgICAgIGNvbnN0IHIxMiA9IC1zeDtcblxuICAgICAgY29uc3QgcjIwID0gLXN5ICogY3ogKyBjeSAqIHN4ICogc3o7XG4gICAgICBjb25zdCByMjEgPSBzeSAqIHN6ICsgY3kgKiBzeCAqIGN6O1xuICAgICAgY29uc3QgcjIyID0gY3kgKiBjeDtcblxuICAgICAgb3V0WzBdID0gcjAwO1xuICAgICAgb3V0WzFdID0gcjEwO1xuICAgICAgb3V0WzJdID0gcjIwO1xuICAgICAgb3V0WzNdID0gcjAxO1xuICAgICAgb3V0WzRdID0gcjExO1xuICAgICAgb3V0WzVdID0gcjIxO1xuICAgICAgb3V0WzZdID0gcjAyO1xuICAgICAgb3V0WzddID0gcjEyO1xuICAgICAgb3V0WzhdID0gcjIyO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgY29uc3QgTk9JU0VfSVNfWkVSTyA9IE5PSVNFIDwgMWUtNjtcbiAgICBsZXQgcmFmID0gMDtcbiAgICBjb25zdCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHN0YXJ0UkFGID0gKCkgPT4ge1xuICAgICAgaWYgKHJhZikgcmV0dXJuO1xuICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgfTtcbiAgICBjb25zdCBzdG9wUkFGID0gKCkgPT4ge1xuICAgICAgaWYgKCFyYWYpIHJldHVybjtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgICByYWYgPSAwO1xuICAgIH07XG5cbiAgICBjb25zdCBybmQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpO1xuICAgIGNvbnN0IHdYID0gKDAuMyArIHJuZCgpICogMC42KSAqIFJTWDtcbiAgICBjb25zdCB3WSA9ICgwLjIgKyBybmQoKSAqIDAuNykgKiBSU1k7XG4gICAgY29uc3Qgd1ogPSAoMC4xICsgcm5kKCkgKiAwLjUpICogUlNaO1xuICAgIGNvbnN0IHBoWCA9IHJuZCgpICogTWF0aC5QSSAqIDI7XG4gICAgY29uc3QgcGhaID0gcm5kKCkgKiBNYXRoLlBJICogMjtcblxuICAgIGxldCB5YXcgPSAwLFxuICAgICAgcGl0Y2ggPSAwLFxuICAgICAgcm9sbCA9IDA7XG4gICAgbGV0IHRhcmdldFlhdyA9IDAsXG4gICAgICB0YXJnZXRQaXRjaCA9IDA7XG4gICAgY29uc3QgbGVycCA9IChhOiBudW1iZXIsIGI6IG51bWJlciwgdDogbnVtYmVyKSA9PiBhICsgKGIgLSBhKSAqIHQ7XG5cbiAgICBjb25zdCBwb2ludGVyID0geyB4OiAwLCB5OiAwLCBpbnNpZGU6IHRydWUgfTtcbiAgICBjb25zdCBvbk1vdmUgPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB3dyA9IE1hdGgubWF4KDEsIHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgICAgIGNvbnN0IHdoID0gTWF0aC5tYXgoMSwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN4ID0gd3cgKiAwLjU7XG4gICAgICBjb25zdCBjeSA9IHdoICogMC41O1xuICAgICAgY29uc3QgbnggPSAoZS5jbGllbnRYIC0gY3gpIC8gKHd3ICogMC41KTtcbiAgICAgIGNvbnN0IG55ID0gKGUuY2xpZW50WSAtIGN5KSAvICh3aCAqIDAuNSk7XG4gICAgICBwb2ludGVyLnggPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgbngpKTtcbiAgICAgIHBvaW50ZXIueSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBueSkpO1xuICAgICAgcG9pbnRlci5pbnNpZGUgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgb25MZWF2ZSA9ICgpID0+IHtcbiAgICAgIHBvaW50ZXIuaW5zaWRlID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBvbkJsdXIgPSAoKSA9PiB7XG4gICAgICBwb2ludGVyLmluc2lkZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgb25Qb2ludGVyTW92ZTogKChlOiBQb2ludGVyRXZlbnQpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwiaG92ZXJcIikge1xuICAgICAgb25Qb2ludGVyTW92ZSA9IChlOiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICAgICAgb25Nb3ZlKGUpO1xuICAgICAgICBzdGFydFJBRigpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTGVhdmUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG9uQmx1cik7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLnVVc2VCYXNlV29iYmxlLnZhbHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwiM2Ryb3RhdGVcIikge1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51VXNlQmFzZVdvYmJsZS52YWx1ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMudVVzZUJhc2VXb2JibGUudmFsdWUgPSAxO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlciA9ICh0OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSAodCAtIHQwKSAqIDAuMDAxO1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5pVGltZS52YWx1ZSA9IHRpbWU7XG5cbiAgICAgIGxldCBjb250aW51ZVJBRiA9IHRydWU7XG5cbiAgICAgIGlmIChhbmltYXRpb25UeXBlID09PSBcImhvdmVyXCIpIHtcbiAgICAgICAgY29uc3QgbWF4UGl0Y2ggPSAwLjYgKiBIT1ZTVFI7XG4gICAgICAgIGNvbnN0IG1heFlhdyA9IDAuNiAqIEhPVlNUUjtcbiAgICAgICAgdGFyZ2V0WWF3ID0gKHBvaW50ZXIuaW5zaWRlID8gLXBvaW50ZXIueCA6IDApICogbWF4WWF3O1xuICAgICAgICB0YXJnZXRQaXRjaCA9IChwb2ludGVyLmluc2lkZSA/IHBvaW50ZXIueSA6IDApICogbWF4UGl0Y2g7XG4gICAgICAgIGNvbnN0IHByZXZZYXcgPSB5YXc7XG4gICAgICAgIGNvbnN0IHByZXZQaXRjaCA9IHBpdGNoO1xuICAgICAgICBjb25zdCBwcmV2Um9sbCA9IHJvbGw7XG4gICAgICAgIHlhdyA9IGxlcnAocHJldllhdywgdGFyZ2V0WWF3LCBJTkVSVCk7XG4gICAgICAgIHBpdGNoID0gbGVycChwcmV2UGl0Y2gsIHRhcmdldFBpdGNoLCBJTkVSVCk7XG4gICAgICAgIHJvbGwgPSBsZXJwKHByZXZSb2xsLCAwLCAwLjEpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm1zLnVSb3QudmFsdWUgPSBzZXRNYXQzRnJvbUV1bGVyKFxuICAgICAgICAgIHlhdyxcbiAgICAgICAgICBwaXRjaCxcbiAgICAgICAgICByb2xsLFxuICAgICAgICAgIHJvdEJ1ZlxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChOT0lTRV9JU19aRVJPKSB7XG4gICAgICAgICAgY29uc3Qgc2V0dGxlZCA9XG4gICAgICAgICAgICBNYXRoLmFicyh5YXcgLSB0YXJnZXRZYXcpIDwgMWUtNCAmJlxuICAgICAgICAgICAgTWF0aC5hYnMocGl0Y2ggLSB0YXJnZXRQaXRjaCkgPCAxZS00ICYmXG4gICAgICAgICAgICBNYXRoLmFicyhyb2xsKSA8IDFlLTQ7XG4gICAgICAgICAgaWYgKHNldHRsZWQpIGNvbnRpbnVlUkFGID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCIzZHJvdGF0ZVwiKSB7XG4gICAgICAgIGNvbnN0IHRTY2FsZWQgPSB0aW1lICogVFM7XG4gICAgICAgIHlhdyA9IHRTY2FsZWQgKiB3WTtcbiAgICAgICAgcGl0Y2ggPSBNYXRoLnNpbih0U2NhbGVkICogd1ggKyBwaFgpICogMC42O1xuICAgICAgICByb2xsID0gTWF0aC5zaW4odFNjYWxlZCAqIHdaICsgcGhaKSAqIDAuNTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51Um90LnZhbHVlID0gc2V0TWF0M0Zyb21FdWxlcihcbiAgICAgICAgICB5YXcsXG4gICAgICAgICAgcGl0Y2gsXG4gICAgICAgICAgcm9sbCxcbiAgICAgICAgICByb3RCdWZcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFRTIDwgMWUtNikgY29udGludWVSQUYgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdEJ1ZlswXSA9IDE7XG4gICAgICAgIHJvdEJ1ZlsxXSA9IDA7XG4gICAgICAgIHJvdEJ1ZlsyXSA9IDA7XG4gICAgICAgIHJvdEJ1ZlszXSA9IDA7XG4gICAgICAgIHJvdEJ1Zls0XSA9IDE7XG4gICAgICAgIHJvdEJ1Zls1XSA9IDA7XG4gICAgICAgIHJvdEJ1Zls2XSA9IDA7XG4gICAgICAgIHJvdEJ1Zls3XSA9IDA7XG4gICAgICAgIHJvdEJ1Zls4XSA9IDE7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybXMudVJvdC52YWx1ZSA9IHJvdEJ1ZjtcbiAgICAgICAgaWYgKFRTIDwgMWUtNikgY29udGludWVSQUYgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIucmVuZGVyKHsgc2NlbmU6IG1lc2ggfSk7XG4gICAgICBpZiAoY29udGludWVSQUYpIHtcbiAgICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYWYgPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbnRlcmZhY2UgUHJpc21Db250YWluZXIgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICBfX3ByaXNtSU8/OiBJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICB9XG5cbiAgICBpZiAoc3VzcGVuZFdoZW5PZmZzY3JlZW4pIHtcbiAgICAgIGNvbnN0IGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpcyA9IGVudHJpZXMuc29tZSgoZSkgPT4gZS5pc0ludGVyc2VjdGluZyk7XG4gICAgICAgIGlmICh2aXMpIHN0YXJ0UkFGKCk7XG4gICAgICAgIGVsc2Ugc3RvcFJBRigpO1xuICAgICAgfSk7XG4gICAgICBpby5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgICBzdGFydFJBRigpO1xuICAgICAgKGNvbnRhaW5lciBhcyBQcmlzbUNvbnRhaW5lcikuX19wcmlzbUlPID0gaW87XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UkFGKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0b3BSQUYoKTtcbiAgICAgIHJvLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGlmIChhbmltYXRpb25UeXBlID09PSBcImhvdmVyXCIpIHtcbiAgICAgICAgaWYgKG9uUG9pbnRlck1vdmUpXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcInBvaW50ZXJtb3ZlXCIsXG4gICAgICAgICAgICBvblBvaW50ZXJNb3ZlIGFzIEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25MZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbkJsdXIpO1xuICAgICAgfVxuICAgICAgaWYgKHN1c3BlbmRXaGVuT2Zmc2NyZWVuKSB7XG4gICAgICAgIGNvbnN0IGlvID0gKGNvbnRhaW5lciBhcyBQcmlzbUNvbnRhaW5lcikuX19wcmlzbUlPIGFzXG4gICAgICAgICAgfCBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaW8pIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZGVsZXRlIChjb250YWluZXIgYXMgUHJpc21Db250YWluZXIpLl9fcHJpc21JTztcbiAgICAgIH1cbiAgICAgIGlmIChnbC5jYW52YXMucGFyZW50RWxlbWVudCA9PT0gY29udGFpbmVyKVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZ2wuY2FudmFzKTtcbiAgICB9O1xuICB9LCBbXG4gICAgZ2xvdyxcbiAgICBub2lzZSxcbiAgICBzY2FsZSxcbiAgICBibG9vbSxcbiAgICBoZWlnaHQsXG4gICAgaW5lcnRpYSxcbiAgICBodWVTaGlmdCxcbiAgICBiYXNlV2lkdGgsXG4gICAgb2Zmc2V0Py54LFxuICAgIG9mZnNldD8ueSxcbiAgICB0aW1lU2NhbGUsXG4gICAgdHJhbnNwYXJlbnQsXG4gICAgYW5pbWF0aW9uVHlwZSxcbiAgICBob3ZlclN0cmVuZ3RoLFxuICAgIGNvbG9yRnJlcXVlbmN5LFxuICAgIHN1c3BlbmRXaGVuT2Zmc2NyZWVuLFxuICBdKTtcblxuICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGFic29sdXRlXCIgcmVmPXtjb250YWluZXJSZWZ9IC8+O1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIk1lc2giLCJQcm9ncmFtIiwiUmVuZGVyZXIiLCJUcmlhbmdsZSIsIlByaXNtIiwiZ2xvdyIsImJsb29tIiwibm9pc2UiLCJzY2FsZSIsImhlaWdodCIsImh1ZVNoaWZ0IiwiaW5lcnRpYSIsImJhc2VXaWR0aCIsInRpbWVTY2FsZSIsImhvdmVyU3RyZW5ndGgiLCJ0cmFuc3BhcmVudCIsImNvbG9yRnJlcXVlbmN5Iiwib2Zmc2V0IiwieCIsInkiLCJhbmltYXRpb25UeXBlIiwic3VzcGVuZFdoZW5PZmZzY3JlZW4iLCJjb250YWluZXJSZWYiLCJjb250YWluZXIiLCJjdXJyZW50IiwiSCIsIk1hdGgiLCJtYXgiLCJCVyIsIkJBU0VfSEFMRiIsIkdMT1ciLCJOT0lTRSIsIm9mZlgiLCJvZmZZIiwiU0FUIiwiU0NBTEUiLCJIVUUiLCJDRlJFUSIsIkJMT09NIiwiUlNYIiwiUlNZIiwiUlNaIiwiVFMiLCJIT1ZTVFIiLCJJTkVSVCIsIm1pbiIsImRwciIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyZW5kZXJlciIsImFscGhhIiwiYW50aWFsaWFzIiwiZ2wiLCJkaXNhYmxlIiwiREVQVEhfVEVTVCIsIkNVTExfRkFDRSIsIkJMRU5EIiwiT2JqZWN0IiwiYXNzaWduIiwiY2FudmFzIiwic3R5bGUiLCJwb3NpdGlvbiIsImluc2V0Iiwid2lkdGgiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJ2ZXJ0ZXgiLCJmcmFnbWVudCIsImdlb21ldHJ5IiwiaVJlc0J1ZiIsIkZsb2F0MzJBcnJheSIsIm9mZnNldFB4QnVmIiwicHJvZ3JhbSIsInVuaWZvcm1zIiwiaVJlc29sdXRpb24iLCJ2YWx1ZSIsImlUaW1lIiwidUhlaWdodCIsInVCYXNlSGFsZiIsInVVc2VCYXNlV29iYmxlIiwidVJvdCIsInVHbG93IiwidU9mZnNldFB4IiwidU5vaXNlIiwidVNhdHVyYXRpb24iLCJ1U2NhbGUiLCJ1SHVlU2hpZnQiLCJ1Q29sb3JGcmVxIiwidUJsb29tIiwidUNlbnRlclNoaWZ0IiwidUludkJhc2VIYWxmIiwidUludkhlaWdodCIsInVNaW5BeGlzIiwidVB4U2NhbGUiLCJkcmF3aW5nQnVmZmVySGVpZ2h0IiwidVRpbWVTY2FsZSIsIm1lc2giLCJyZXNpemUiLCJ3IiwiY2xpZW50V2lkdGgiLCJoIiwiY2xpZW50SGVpZ2h0Iiwic2V0U2l6ZSIsImRyYXdpbmdCdWZmZXJXaWR0aCIsInJvIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwicm90QnVmIiwic2V0TWF0M0Zyb21FdWxlciIsInlhd1kiLCJwaXRjaFgiLCJyb2xsWiIsIm91dCIsImN5IiwiY29zIiwic3kiLCJzaW4iLCJjeCIsInN4IiwiY3oiLCJzeiIsInIwMCIsInIwMSIsInIwMiIsInIxMCIsInIxMSIsInIxMiIsInIyMCIsInIyMSIsInIyMiIsIk5PSVNFX0lTX1pFUk8iLCJyYWYiLCJ0MCIsInBlcmZvcm1hbmNlIiwibm93Iiwic3RhcnRSQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZW5kZXIiLCJzdG9wUkFGIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJybmQiLCJyYW5kb20iLCJ3WCIsIndZIiwid1oiLCJwaFgiLCJQSSIsInBoWiIsInlhdyIsInBpdGNoIiwicm9sbCIsInRhcmdldFlhdyIsInRhcmdldFBpdGNoIiwibGVycCIsImEiLCJiIiwidCIsInBvaW50ZXIiLCJpbnNpZGUiLCJvbk1vdmUiLCJlIiwid3ciLCJpbm5lcldpZHRoIiwid2giLCJpbm5lckhlaWdodCIsIm54IiwiY2xpZW50WCIsIm55IiwiY2xpZW50WSIsIm9uTGVhdmUiLCJvbkJsdXIiLCJvblBvaW50ZXJNb3ZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJ0aW1lIiwiY29udGludWVSQUYiLCJtYXhQaXRjaCIsIm1heFlhdyIsInByZXZZYXciLCJwcmV2UGl0Y2giLCJwcmV2Um9sbCIsInNldHRsZWQiLCJhYnMiLCJ0U2NhbGVkIiwic2NlbmUiLCJpbyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cmllcyIsInZpcyIsInNvbWUiLCJpc0ludGVyc2VjdGluZyIsIl9fcHJpc21JTyIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50RWxlbWVudCIsInJlbW92ZUNoaWxkIiwiZGl2IiwiY2xhc3NOYW1lIiwicmVmIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/ui/prisma-background/index.tsx\n"));

/***/ })

});