"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/shared/ui/prisma-background/index.tsx":
/*!***************************************************!*\
  !*** ./src/shared/ui/prisma-background/index.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Prism: () => (/* binding */ Prism)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Prism = (param)=>{\n    let { glow = 1, bloom = 0.1, noise = 0.1, scale = 3.6, height = 3.5, hueShift = 0, inertia = 0.05, baseWidth = 5.5, timeScale = 0.5, hoverStrength = 2, transparent = true, colorFrequency = 1, offset = {\n        x: 0,\n        y: 0\n    }, animationType = \"rotate\", suspendWhenOffscreen = false } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Prism.useEffect\": ()=>{\n            const container = containerRef.current;\n            if (!container) return;\n            const H = Math.max(0.001, height);\n            const BW = Math.max(0.001, baseWidth);\n            const BASE_HALF = BW * 0.5;\n            const GLOW = Math.max(0.0, glow);\n            const NOISE = Math.max(0.0, noise);\n            var _offset_x;\n            const offX = (_offset_x = offset === null || offset === void 0 ? void 0 : offset.x) !== null && _offset_x !== void 0 ? _offset_x : 0;\n            var _offset_y;\n            const offY = (_offset_y = offset === null || offset === void 0 ? void 0 : offset.y) !== null && _offset_y !== void 0 ? _offset_y : 0;\n            const SAT = transparent ? 1.5 : 1;\n            const SCALE = Math.max(0.001, scale);\n            const HUE = hueShift || 0;\n            const CFREQ = Math.max(0.0, colorFrequency || 1);\n            const BLOOM = Math.max(0.0, bloom || 1);\n            const RSX = 1;\n            const RSY = 1;\n            const RSZ = 1;\n            const TS = Math.max(0, timeScale || 1);\n            const HOVSTR = Math.max(0, hoverStrength || 1);\n            const INERT = Math.max(0, Math.min(1, inertia || 0.12));\n            const dpr = Math.min(2, window.devicePixelRatio || 1);\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_2__.Renderer({\n                dpr,\n                alpha: transparent,\n                antialias: false\n            });\n            const gl = renderer.gl;\n            gl.disable(gl.DEPTH_TEST);\n            gl.disable(gl.CULL_FACE);\n            gl.disable(gl.BLEND);\n            Object.assign(gl.canvas.style, {\n                position: \"absolute\",\n                inset: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                display: \"block\"\n            });\n            container.appendChild(gl.canvas);\n            const vertex = \"\\n      attribute vec2 position;\\n      void main() {\\n        gl_Position = vec4(position, 0.0, 1.0);\\n      }\\n    \";\n            const fragment = \"\\n      precision highp float;\\n\\n      uniform vec2  iResolution;\\n      uniform float iTime;\\n\\n      uniform float uHeight;\\n      uniform float uBaseHalf;\\n      uniform mat3  uRot;\\n      uniform int   uUseBaseWobble;\\n      uniform float uGlow;\\n      uniform vec2  uOffsetPx;\\n      uniform float uNoise;\\n      uniform float uSaturation;\\n      uniform float uScale;\\n      uniform float uHueShift;\\n      uniform float uColorFreq;\\n      uniform float uBloom;\\n      uniform float uCenterShift;\\n      uniform float uInvBaseHalf;\\n      uniform float uInvHeight;\\n      uniform float uMinAxis;\\n      uniform float uPxScale;\\n      uniform float uTimeScale;\\n\\n      vec4 tanh4(vec4 x){\\n        vec4 e2x = exp(2.0*x);\\n        return (e2x - 1.0) / (e2x + 1.0);\\n      }\\n\\n      float rand(vec2 co){\\n        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\\n      }\\n\\n      float sdOctaAnisoInv(vec3 p){\\n        vec3 q = vec3(abs(p.x) * uInvBaseHalf, abs(p.y) * uInvHeight, abs(p.z) * uInvBaseHalf);\\n        float m = q.x + q.y + q.z - 1.0;\\n        return m * uMinAxis * 0.5773502691896258;\\n      }\\n\\n      float sdPyramidUpInv(vec3 p){\\n        float oct = sdOctaAnisoInv(p);\\n        float halfSpace = -p.y;\\n        return max(oct, halfSpace);\\n      }\\n\\n      mat3 hueRotation(float a){\\n        float c = cos(a), s = sin(a);\\n        mat3 W = mat3(\\n          0.299, 0.587, 0.114,\\n          0.299, 0.587, 0.114,\\n          0.299, 0.587, 0.114\\n        );\\n        mat3 U = mat3(\\n           0.701, -0.587, -0.114,\\n          -0.299,  0.413, -0.114,\\n          -0.300, -0.588,  0.886\\n        );\\n        mat3 V = mat3(\\n           0.168, -0.331,  0.500,\\n           0.328,  0.035, -0.500,\\n          -0.497,  0.296,  0.201\\n        );\\n        return W + U * c + V * s;\\n      }\\n\\n      void main(){\\n        vec2 f = (gl_FragCoord.xy - 0.5 * iResolution.xy - uOffsetPx) * uPxScale;\\n\\n        float z = 5.0;\\n        float d = 0.0;\\n\\n        vec3 p;\\n        vec4 o = vec4(0.0);\\n\\n        float centerShift = uCenterShift;\\n        float cf = uColorFreq;\\n\\n        mat2 wob = mat2(1.0);\\n        if (uUseBaseWobble == 1) {\\n          float t = iTime * uTimeScale;\\n          float c0 = cos(t + 0.0);\\n          float c1 = cos(t + 33.0);\\n          float c2 = cos(t + 11.0);\\n          wob = mat2(c0, c1, c2, c0);\\n        }\\n\\n        const int STEPS = 100;\\n        for (int i = 0; i < STEPS; i++) {\\n          p = vec3(f, z);\\n          p.xz = p.xz * wob;\\n          p = uRot * p;\\n          vec3 q = p;\\n          q.y += centerShift;\\n          d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));\\n          z -= d;\\n          o += (sin((p.y + z) * cf + vec4(0.0, 1.0, 2.0, 3.0)) + 1.0) / d;\\n        }\\n\\n        o = tanh4(o * o * (uGlow * uBloom) / 1e5);\\n\\n        vec3 col = o.rgb;\\n        float n = rand(gl_FragCoord.xy + vec2(iTime));\\n        col += (n - 0.5) * uNoise;\\n        col = clamp(col, 0.0, 1.0);\\n\\n        float L = dot(col, vec3(0.2126, 0.7152, 0.0722));\\n        col = clamp(mix(vec3(L), col, uSaturation), 0.0, 1.0);\\n\\n        if(abs(uHueShift) > 0.0001){\\n          col = clamp(hueRotation(uHueShift) * col, 0.0, 1.0);\\n        }\\n\\n        gl_FragColor = vec4(col, o.a);\\n      }\\n    \";\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_3__.Triangle(gl);\n            const iResBuf = new Float32Array(2);\n            const offsetPxBuf = new Float32Array(2);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_4__.Program(gl, {\n                vertex,\n                fragment,\n                uniforms: {\n                    iResolution: {\n                        value: iResBuf\n                    },\n                    iTime: {\n                        value: 0\n                    },\n                    uHeight: {\n                        value: H\n                    },\n                    uBaseHalf: {\n                        value: BASE_HALF\n                    },\n                    uUseBaseWobble: {\n                        value: 1\n                    },\n                    uRot: {\n                        value: new Float32Array([\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1\n                        ])\n                    },\n                    uGlow: {\n                        value: GLOW\n                    },\n                    uOffsetPx: {\n                        value: offsetPxBuf\n                    },\n                    uNoise: {\n                        value: NOISE\n                    },\n                    uSaturation: {\n                        value: SAT\n                    },\n                    uScale: {\n                        value: SCALE\n                    },\n                    uHueShift: {\n                        value: HUE\n                    },\n                    uColorFreq: {\n                        value: CFREQ\n                    },\n                    uBloom: {\n                        value: BLOOM\n                    },\n                    uCenterShift: {\n                        value: H * 0.25\n                    },\n                    uInvBaseHalf: {\n                        value: 1 / BASE_HALF\n                    },\n                    uInvHeight: {\n                        value: 1 / H\n                    },\n                    uMinAxis: {\n                        value: Math.min(BASE_HALF, H)\n                    },\n                    uPxScale: {\n                        value: 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE)\n                    },\n                    uTimeScale: {\n                        value: TS\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_5__.Mesh(gl, {\n                geometry,\n                program\n            });\n            const resize = {\n                \"Prism.useEffect.resize\": ()=>{\n                    const w = container.clientWidth || 1;\n                    const h = container.clientHeight || 1;\n                    renderer.setSize(w, h);\n                    iResBuf[0] = gl.drawingBufferWidth;\n                    iResBuf[1] = gl.drawingBufferHeight;\n                    offsetPxBuf[0] = offX * dpr;\n                    offsetPxBuf[1] = offY * dpr;\n                    program.uniforms.uPxScale.value = 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE);\n                }\n            }[\"Prism.useEffect.resize\"];\n            const ro = new ResizeObserver(resize);\n            ro.observe(container);\n            resize();\n            const rotBuf = new Float32Array(9);\n            const setMat3FromEuler = {\n                \"Prism.useEffect.setMat3FromEuler\": (yawY, pitchX, rollZ, out)=>{\n                    const cy = Math.cos(yawY), sy = Math.sin(yawY);\n                    const cx = Math.cos(pitchX), sx = Math.sin(pitchX);\n                    const cz = Math.cos(rollZ), sz = Math.sin(rollZ);\n                    const r00 = cy * cz + sy * sx * sz;\n                    const r01 = -cy * sz + sy * sx * cz;\n                    const r02 = sy * cx;\n                    const r10 = cx * sz;\n                    const r11 = cx * cz;\n                    const r12 = -sx;\n                    const r20 = -sy * cz + cy * sx * sz;\n                    const r21 = sy * sz + cy * sx * cz;\n                    const r22 = cy * cx;\n                    out[0] = r00;\n                    out[1] = r10;\n                    out[2] = r20;\n                    out[3] = r01;\n                    out[4] = r11;\n                    out[5] = r21;\n                    out[6] = r02;\n                    out[7] = r12;\n                    out[8] = r22;\n                    return out;\n                }\n            }[\"Prism.useEffect.setMat3FromEuler\"];\n            const NOISE_IS_ZERO = NOISE < 1e-6;\n            let raf = 0;\n            const t0 = performance.now();\n            const startRAF = {\n                \"Prism.useEffect.startRAF\": ()=>{\n                    if (raf) return;\n                    raf = requestAnimationFrame(render);\n                }\n            }[\"Prism.useEffect.startRAF\"];\n            const stopRAF = {\n                \"Prism.useEffect.stopRAF\": ()=>{\n                    if (!raf) return;\n                    cancelAnimationFrame(raf);\n                    raf = 0;\n                }\n            }[\"Prism.useEffect.stopRAF\"];\n            const rnd = {\n                \"Prism.useEffect.rnd\": ()=>Math.random()\n            }[\"Prism.useEffect.rnd\"];\n            const wX = (0.3 + rnd() * 0.6) * RSX;\n            const wY = (0.2 + rnd() * 0.7) * RSY;\n            const wZ = (0.1 + rnd() * 0.5) * RSZ;\n            const phX = rnd() * Math.PI * 2;\n            const phZ = rnd() * Math.PI * 2;\n            let yaw = 0, pitch = 0, roll = 0;\n            let targetYaw = 0, targetPitch = 0;\n            const lerp = {\n                \"Prism.useEffect.lerp\": (a, b, t)=>a + (b - a) * t\n            }[\"Prism.useEffect.lerp\"];\n            const pointer = {\n                x: 0,\n                y: 0,\n                inside: true\n            };\n            const onMove = {\n                \"Prism.useEffect.onMove\": (e)=>{\n                    const ww = Math.max(1, window.innerWidth);\n                    const wh = Math.max(1, window.innerHeight);\n                    const cx = ww * 0.5;\n                    const cy = wh * 0.5;\n                    const nx = (e.clientX - cx) / (ww * 0.5);\n                    const ny = (e.clientY - cy) / (wh * 0.5);\n                    pointer.x = Math.max(-1, Math.min(1, nx));\n                    pointer.y = Math.max(-1, Math.min(1, ny));\n                    pointer.inside = true;\n                }\n            }[\"Prism.useEffect.onMove\"];\n            const onLeave = {\n                \"Prism.useEffect.onLeave\": ()=>{\n                    pointer.inside = false;\n                }\n            }[\"Prism.useEffect.onLeave\"];\n            const onBlur = {\n                \"Prism.useEffect.onBlur\": ()=>{\n                    pointer.inside = false;\n                }\n            }[\"Prism.useEffect.onBlur\"];\n            let onPointerMove = null;\n            if (animationType === \"hover\") {\n                onPointerMove = ({\n                    \"Prism.useEffect\": (e)=>{\n                        onMove(e);\n                        startRAF();\n                    }\n                })[\"Prism.useEffect\"];\n                window.addEventListener(\"pointermove\", onPointerMove, {\n                    passive: true\n                });\n                window.addEventListener(\"mouseleave\", onLeave);\n                window.addEventListener(\"blur\", onBlur);\n                program.uniforms.uUseBaseWobble.value = 0;\n            } else if (animationType === \"3drotate\") {\n                program.uniforms.uUseBaseWobble.value = 0;\n            } else {\n                program.uniforms.uUseBaseWobble.value = 1;\n            }\n            const render = {\n                \"Prism.useEffect.render\": (t)=>{\n                    const time = (t - t0) * 0.001;\n                    program.uniforms.iTime.value = time;\n                    let continueRAF = true;\n                    if (animationType === \"hover\") {\n                        const maxPitch = 0.6 * HOVSTR;\n                        const maxYaw = 0.6 * HOVSTR;\n                        targetYaw = (pointer.inside ? -pointer.x : 0) * maxYaw;\n                        targetPitch = (pointer.inside ? pointer.y : 0) * maxPitch;\n                        const prevYaw = yaw;\n                        const prevPitch = pitch;\n                        const prevRoll = roll;\n                        yaw = lerp(prevYaw, targetYaw, INERT);\n                        pitch = lerp(prevPitch, targetPitch, INERT);\n                        roll = lerp(prevRoll, 0, 0.1);\n                        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n                        if (NOISE_IS_ZERO) {\n                            const settled = Math.abs(yaw - targetYaw) < 1e-4 && Math.abs(pitch - targetPitch) < 1e-4 && Math.abs(roll) < 1e-4;\n                            if (settled) continueRAF = false;\n                        }\n                    } else if (animationType === \"3drotate\") {\n                        const tScaled = time * TS;\n                        yaw = tScaled * wY;\n                        pitch = Math.sin(tScaled * wX + phX) * 0.6;\n                        roll = Math.sin(tScaled * wZ + phZ) * 0.5;\n                        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n                        if (TS < 1e-6) continueRAF = false;\n                    } else {\n                        rotBuf[0] = 1;\n                        rotBuf[1] = 0;\n                        rotBuf[2] = 0;\n                        rotBuf[3] = 0;\n                        rotBuf[4] = 1;\n                        rotBuf[5] = 0;\n                        rotBuf[6] = 0;\n                        rotBuf[7] = 0;\n                        rotBuf[8] = 1;\n                        program.uniforms.uRot.value = rotBuf;\n                        if (TS < 1e-6) continueRAF = false;\n                    }\n                    renderer.render({\n                        scene: mesh\n                    });\n                    if (continueRAF) {\n                        raf = requestAnimationFrame(render);\n                    } else {\n                        raf = 0;\n                    }\n                }\n            }[\"Prism.useEffect.render\"];\n            if (suspendWhenOffscreen) {\n                const io = new IntersectionObserver({\n                    \"Prism.useEffect\": (entries)=>{\n                        const vis = entries.some({\n                            \"Prism.useEffect.vis\": (e)=>e.isIntersecting\n                        }[\"Prism.useEffect.vis\"]);\n                        if (vis) startRAF();\n                        else stopRAF();\n                    }\n                }[\"Prism.useEffect\"]);\n                io.observe(container);\n                startRAF();\n                container.__prismIO = io;\n            } else {\n                startRAF();\n            }\n            return ({\n                \"Prism.useEffect\": ()=>{\n                    stopRAF();\n                    ro.disconnect();\n                    if (animationType === \"hover\") {\n                        if (onPointerMove) window.removeEventListener(\"pointermove\", onPointerMove);\n                        window.removeEventListener(\"mouseleave\", onLeave);\n                        window.removeEventListener(\"blur\", onBlur);\n                    }\n                    if (suspendWhenOffscreen) {\n                        const io = container.__prismIO;\n                        if (io) io.disconnect();\n                        delete container.__prismIO;\n                    }\n                    if (gl.canvas.parentElement === container) container.removeChild(gl.canvas);\n                }\n            })[\"Prism.useEffect\"];\n        }\n    }[\"Prism.useEffect\"], [\n        glow,\n        noise,\n        scale,\n        bloom,\n        height,\n        inertia,\n        hueShift,\n        baseWidth,\n        offset === null || offset === void 0 ? void 0 : offset.x,\n        offset === null || offset === void 0 ? void 0 : offset.y,\n        timeScale,\n        transparent,\n        animationType,\n        hoverStrength,\n        colorFrequency,\n        suspendWhenOffscreen\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full absolute\",\n        ref: containerRef\n    }, void 0, false, {\n        fileName: \"/Users/cloudmenson/Desktop/Files/Programming/My portfolio website/designer-portfolio/src/shared/ui/prisma-background/index.tsx\",\n        lineNumber: 479,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Prism, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = Prism;\nvar _c;\n$RefreshReg$(_c, \"Prism\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvdWkvcHJpc21hLWJhY2tncm91bmQvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTztBQW9CakQsTUFBTU8sUUFBOEI7UUFBQyxFQUMxQ0MsT0FBTyxDQUFDLEVBQ1JDLFFBQVEsR0FBRyxFQUNYQyxRQUFRLEdBQUcsRUFDWEMsUUFBUSxHQUFHLEVBQ1hDLFNBQVMsR0FBRyxFQUNaQyxXQUFXLENBQUMsRUFDWkMsVUFBVSxJQUFJLEVBQ2RDLFlBQVksR0FBRyxFQUNmQyxZQUFZLEdBQUcsRUFDZkMsZ0JBQWdCLENBQUMsRUFDakJDLGNBQWMsSUFBSSxFQUNsQkMsaUJBQWlCLENBQUMsRUFDbEJDLFNBQVM7UUFBRUMsR0FBRztRQUFHQyxHQUFHO0lBQUUsQ0FBQyxFQUN2QkMsZ0JBQWdCLFFBQVEsRUFDeEJDLHVCQUF1QixLQUFLLEVBQzdCOztJQUNDLE1BQU1DLGVBQWV2Qiw2Q0FBTUEsQ0FBd0I7SUFFbkRELGdEQUFTQTsyQkFBQztZQUNSLE1BQU15QixZQUFZRCxhQUFhRSxPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsV0FBVztZQUVoQixNQUFNRSxJQUFJQyxLQUFLQyxHQUFHLENBQUMsT0FBT2xCO1lBQzFCLE1BQU1tQixLQUFLRixLQUFLQyxHQUFHLENBQUMsT0FBT2Y7WUFDM0IsTUFBTWlCLFlBQVlELEtBQUs7WUFDdkIsTUFBTUUsT0FBT0osS0FBS0MsR0FBRyxDQUFDLEtBQUt0QjtZQUMzQixNQUFNMEIsUUFBUUwsS0FBS0MsR0FBRyxDQUFDLEtBQUtwQjtnQkFDZlU7WUFBYixNQUFNZSxPQUFPZixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFDLENBQUMsY0FBVEQsdUJBQUFBLFlBQWE7Z0JBQ2JBO1lBQWIsTUFBTWdCLE9BQU9oQixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFFLENBQUMsY0FBVEYsdUJBQUFBLFlBQWE7WUFDMUIsTUFBTWlCLE1B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O1FBQ0FFO1FBQ0FLO0tBQ0Q7SUFFRCxxQkFBTyw4REFBQytLO1FBQUlDLFdBQVU7UUFBeUJDLEtBQUtoTDs7Ozs7O0FBQ3RELEVBQUU7R0ExY1dsQjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2Nsb3VkbWVuc29uL0Rlc2t0b3AvRmlsZXMvUHJvZ3JhbW1pbmcvTXkgcG9ydGZvbGlvIHdlYnNpdGUvZGVzaWduZXItcG9ydGZvbGlvL3NyYy9zaGFyZWQvdWkvcHJpc21hLWJhY2tncm91bmQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTWVzaCwgUHJvZ3JhbSwgUmVuZGVyZXIsIFRyaWFuZ2xlIH0gZnJvbSBcIm9nbFwiO1xuXG50eXBlIFByaXNtUHJvcHMgPSB7XG4gIGdsb3c/OiBudW1iZXI7XG4gIG5vaXNlPzogbnVtYmVyO1xuICBzY2FsZT86IG51bWJlcjtcbiAgYmxvb20/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgaW5lcnRpYT86IG51bWJlcjtcbiAgaHVlU2hpZnQ/OiBudW1iZXI7XG4gIGJhc2VXaWR0aD86IG51bWJlcjtcbiAgdGltZVNjYWxlPzogbnVtYmVyO1xuICB0cmFuc3BhcmVudD86IGJvb2xlYW47XG4gIGhvdmVyU3RyZW5ndGg/OiBudW1iZXI7XG4gIGNvbG9yRnJlcXVlbmN5PzogbnVtYmVyO1xuICBzdXNwZW5kV2hlbk9mZnNjcmVlbj86IGJvb2xlYW47XG4gIG9mZnNldD86IHsgeD86IG51bWJlcjsgeT86IG51bWJlciB9O1xuICBhbmltYXRpb25UeXBlPzogXCJyb3RhdGVcIiB8IFwiaG92ZXJcIiB8IFwiM2Ryb3RhdGVcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBQcmlzbTogUmVhY3QuRkM8UHJpc21Qcm9wcz4gPSAoe1xuICBnbG93ID0gMSxcbiAgYmxvb20gPSAwLjEsXG4gIG5vaXNlID0gMC4xLFxuICBzY2FsZSA9IDMuNixcbiAgaGVpZ2h0ID0gMy41LFxuICBodWVTaGlmdCA9IDAsXG4gIGluZXJ0aWEgPSAwLjA1LFxuICBiYXNlV2lkdGggPSA1LjUsXG4gIHRpbWVTY2FsZSA9IDAuNSxcbiAgaG92ZXJTdHJlbmd0aCA9IDIsXG4gIHRyYW5zcGFyZW50ID0gdHJ1ZSxcbiAgY29sb3JGcmVxdWVuY3kgPSAxLFxuICBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfSxcbiAgYW5pbWF0aW9uVHlwZSA9IFwicm90YXRlXCIsXG4gIHN1c3BlbmRXaGVuT2Zmc2NyZWVuID0gZmFsc2UsXG59KSA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICAgIGNvbnN0IEggPSBNYXRoLm1heCgwLjAwMSwgaGVpZ2h0KTtcbiAgICBjb25zdCBCVyA9IE1hdGgubWF4KDAuMDAxLCBiYXNlV2lkdGgpO1xuICAgIGNvbnN0IEJBU0VfSEFMRiA9IEJXICogMC41O1xuICAgIGNvbnN0IEdMT1cgPSBNYXRoLm1heCgwLjAsIGdsb3cpO1xuICAgIGNvbnN0IE5PSVNFID0gTWF0aC5tYXgoMC4wLCBub2lzZSk7XG4gICAgY29uc3Qgb2ZmWCA9IG9mZnNldD8ueCA/PyAwO1xuICAgIGNvbnN0IG9mZlkgPSBvZmZzZXQ/LnkgPz8gMDtcbiAgICBjb25zdCBTQVQgPSB0cmFuc3BhcmVudCA/IDEuNSA6IDE7XG4gICAgY29uc3QgU0NBTEUgPSBNYXRoLm1heCgwLjAwMSwgc2NhbGUpO1xuICAgIGNvbnN0IEhVRSA9IGh1ZVNoaWZ0IHx8IDA7XG4gICAgY29uc3QgQ0ZSRVEgPSBNYXRoLm1heCgwLjAsIGNvbG9yRnJlcXVlbmN5IHx8IDEpO1xuICAgIGNvbnN0IEJMT09NID0gTWF0aC5tYXgoMC4wLCBibG9vbSB8fCAxKTtcbiAgICBjb25zdCBSU1ggPSAxO1xuICAgIGNvbnN0IFJTWSA9IDE7XG4gICAgY29uc3QgUlNaID0gMTtcbiAgICBjb25zdCBUUyA9IE1hdGgubWF4KDAsIHRpbWVTY2FsZSB8fCAxKTtcbiAgICBjb25zdCBIT1ZTVFIgPSBNYXRoLm1heCgwLCBob3ZlclN0cmVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IElORVJUID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaW5lcnRpYSB8fCAwLjEyKSk7XG5cbiAgICBjb25zdCBkcHIgPSBNYXRoLm1pbigyLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XG4gICAgICBkcHIsXG4gICAgICBhbHBoYTogdHJhbnNwYXJlbnQsXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICBPYmplY3QuYXNzaWduKGdsLmNhbnZhcy5zdHlsZSwge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIGluc2V0OiBcIjBcIixcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgfSBhcyBQYXJ0aWFsPENTU1N0eWxlRGVjbGFyYXRpb24+KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2wuY2FudmFzKTtcblxuICAgIGNvbnN0IHZlcnRleCA9IC8qIGdsc2wgKi8gYFxuICAgICAgYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi8gYFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgICB1bmlmb3JtIHZlYzIgIGlSZXNvbHV0aW9uO1xuICAgICAgdW5pZm9ybSBmbG9hdCBpVGltZTtcblxuICAgICAgdW5pZm9ybSBmbG9hdCB1SGVpZ2h0O1xuICAgICAgdW5pZm9ybSBmbG9hdCB1QmFzZUhhbGY7XG4gICAgICB1bmlmb3JtIG1hdDMgIHVSb3Q7XG4gICAgICB1bmlmb3JtIGludCAgIHVVc2VCYXNlV29iYmxlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1R2xvdztcbiAgICAgIHVuaWZvcm0gdmVjMiAgdU9mZnNldFB4O1xuICAgICAgdW5pZm9ybSBmbG9hdCB1Tm9pc2U7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVTYXR1cmF0aW9uO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1U2NhbGU7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVIdWVTaGlmdDtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUNvbG9yRnJlcTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUJsb29tO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1Q2VudGVyU2hpZnQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVJbnZCYXNlSGFsZjtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUludkhlaWdodDtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdU1pbkF4aXM7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVQeFNjYWxlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZVNjYWxlO1xuXG4gICAgICB2ZWM0IHRhbmg0KHZlYzQgeCl7XG4gICAgICAgIHZlYzQgZTJ4ID0gZXhwKDIuMCp4KTtcbiAgICAgICAgcmV0dXJuIChlMnggLSAxLjApIC8gKGUyeCArIDEuMCk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHJhbmQodmVjMiBjbyl7XG4gICAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBzZE9jdGFBbmlzb0ludih2ZWMzIHApe1xuICAgICAgICB2ZWMzIHEgPSB2ZWMzKGFicyhwLngpICogdUludkJhc2VIYWxmLCBhYnMocC55KSAqIHVJbnZIZWlnaHQsIGFicyhwLnopICogdUludkJhc2VIYWxmKTtcbiAgICAgICAgZmxvYXQgbSA9IHEueCArIHEueSArIHEueiAtIDEuMDtcbiAgICAgICAgcmV0dXJuIG0gKiB1TWluQXhpcyAqIDAuNTc3MzUwMjY5MTg5NjI1ODtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgc2RQeXJhbWlkVXBJbnYodmVjMyBwKXtcbiAgICAgICAgZmxvYXQgb2N0ID0gc2RPY3RhQW5pc29JbnYocCk7XG4gICAgICAgIGZsb2F0IGhhbGZTcGFjZSA9IC1wLnk7XG4gICAgICAgIHJldHVybiBtYXgob2N0LCBoYWxmU3BhY2UpO1xuICAgICAgfVxuXG4gICAgICBtYXQzIGh1ZVJvdGF0aW9uKGZsb2F0IGEpe1xuICAgICAgICBmbG9hdCBjID0gY29zKGEpLCBzID0gc2luKGEpO1xuICAgICAgICBtYXQzIFcgPSBtYXQzKFxuICAgICAgICAgIDAuMjk5LCAwLjU4NywgMC4xMTQsXG4gICAgICAgICAgMC4yOTksIDAuNTg3LCAwLjExNCxcbiAgICAgICAgICAwLjI5OSwgMC41ODcsIDAuMTE0XG4gICAgICAgICk7XG4gICAgICAgIG1hdDMgVSA9IG1hdDMoXG4gICAgICAgICAgIDAuNzAxLCAtMC41ODcsIC0wLjExNCxcbiAgICAgICAgICAtMC4yOTksICAwLjQxMywgLTAuMTE0LFxuICAgICAgICAgIC0wLjMwMCwgLTAuNTg4LCAgMC44ODZcbiAgICAgICAgKTtcbiAgICAgICAgbWF0MyBWID0gbWF0MyhcbiAgICAgICAgICAgMC4xNjgsIC0wLjMzMSwgIDAuNTAwLFxuICAgICAgICAgICAwLjMyOCwgIDAuMDM1LCAtMC41MDAsXG4gICAgICAgICAgLTAuNDk3LCAgMC4yOTYsICAwLjIwMVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gVyArIFUgKiBjICsgViAqIHM7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpe1xuICAgICAgICB2ZWMyIGYgPSAoZ2xfRnJhZ0Nvb3JkLnh5IC0gMC41ICogaVJlc29sdXRpb24ueHkgLSB1T2Zmc2V0UHgpICogdVB4U2NhbGU7XG5cbiAgICAgICAgZmxvYXQgeiA9IDUuMDtcbiAgICAgICAgZmxvYXQgZCA9IDAuMDtcblxuICAgICAgICB2ZWMzIHA7XG4gICAgICAgIHZlYzQgbyA9IHZlYzQoMC4wKTtcblxuICAgICAgICBmbG9hdCBjZW50ZXJTaGlmdCA9IHVDZW50ZXJTaGlmdDtcbiAgICAgICAgZmxvYXQgY2YgPSB1Q29sb3JGcmVxO1xuXG4gICAgICAgIG1hdDIgd29iID0gbWF0MigxLjApO1xuICAgICAgICBpZiAodVVzZUJhc2VXb2JibGUgPT0gMSkge1xuICAgICAgICAgIGZsb2F0IHQgPSBpVGltZSAqIHVUaW1lU2NhbGU7XG4gICAgICAgICAgZmxvYXQgYzAgPSBjb3ModCArIDAuMCk7XG4gICAgICAgICAgZmxvYXQgYzEgPSBjb3ModCArIDMzLjApO1xuICAgICAgICAgIGZsb2F0IGMyID0gY29zKHQgKyAxMS4wKTtcbiAgICAgICAgICB3b2IgPSBtYXQyKGMwLCBjMSwgYzIsIGMwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGludCBTVEVQUyA9IDEwMDtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBTVEVQUzsgaSsrKSB7XG4gICAgICAgICAgcCA9IHZlYzMoZiwgeik7XG4gICAgICAgICAgcC54eiA9IHAueHogKiB3b2I7XG4gICAgICAgICAgcCA9IHVSb3QgKiBwO1xuICAgICAgICAgIHZlYzMgcSA9IHA7XG4gICAgICAgICAgcS55ICs9IGNlbnRlclNoaWZ0O1xuICAgICAgICAgIGQgPSAwLjEgKyAwLjIgKiBhYnMoc2RQeXJhbWlkVXBJbnYocSkpO1xuICAgICAgICAgIHogLT0gZDtcbiAgICAgICAgICBvICs9IChzaW4oKHAueSArIHopICogY2YgKyB2ZWM0KDAuMCwgMS4wLCAyLjAsIDMuMCkpICsgMS4wKSAvIGQ7XG4gICAgICAgIH1cblxuICAgICAgICBvID0gdGFuaDQobyAqIG8gKiAodUdsb3cgKiB1Qmxvb20pIC8gMWU1KTtcblxuICAgICAgICB2ZWMzIGNvbCA9IG8ucmdiO1xuICAgICAgICBmbG9hdCBuID0gcmFuZChnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKGlUaW1lKSk7XG4gICAgICAgIGNvbCArPSAobiAtIDAuNSkgKiB1Tm9pc2U7XG4gICAgICAgIGNvbCA9IGNsYW1wKGNvbCwgMC4wLCAxLjApO1xuXG4gICAgICAgIGZsb2F0IEwgPSBkb3QoY29sLCB2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKTtcbiAgICAgICAgY29sID0gY2xhbXAobWl4KHZlYzMoTCksIGNvbCwgdVNhdHVyYXRpb24pLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgaWYoYWJzKHVIdWVTaGlmdCkgPiAwLjAwMDEpe1xuICAgICAgICAgIGNvbCA9IGNsYW1wKGh1ZVJvdGF0aW9uKHVIdWVTaGlmdCkgKiBjb2wsIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLCBvLmEpO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUcmlhbmdsZShnbCk7XG4gICAgY29uc3QgaVJlc0J1ZiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgY29uc3Qgb2Zmc2V0UHhCdWYgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlSZXNvbHV0aW9uOiB7IHZhbHVlOiBpUmVzQnVmIH0sXG4gICAgICAgIGlUaW1lOiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIHVIZWlnaHQ6IHsgdmFsdWU6IEggfSxcbiAgICAgICAgdUJhc2VIYWxmOiB7IHZhbHVlOiBCQVNFX0hBTEYgfSxcbiAgICAgICAgdVVzZUJhc2VXb2JibGU6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgdVJvdDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pIH0sXG4gICAgICAgIHVHbG93OiB7IHZhbHVlOiBHTE9XIH0sXG4gICAgICAgIHVPZmZzZXRQeDogeyB2YWx1ZTogb2Zmc2V0UHhCdWYgfSxcbiAgICAgICAgdU5vaXNlOiB7IHZhbHVlOiBOT0lTRSB9LFxuICAgICAgICB1U2F0dXJhdGlvbjogeyB2YWx1ZTogU0FUIH0sXG4gICAgICAgIHVTY2FsZTogeyB2YWx1ZTogU0NBTEUgfSxcbiAgICAgICAgdUh1ZVNoaWZ0OiB7IHZhbHVlOiBIVUUgfSxcbiAgICAgICAgdUNvbG9yRnJlcTogeyB2YWx1ZTogQ0ZSRVEgfSxcbiAgICAgICAgdUJsb29tOiB7IHZhbHVlOiBCTE9PTSB9LFxuICAgICAgICB1Q2VudGVyU2hpZnQ6IHsgdmFsdWU6IEggKiAwLjI1IH0sXG4gICAgICAgIHVJbnZCYXNlSGFsZjogeyB2YWx1ZTogMSAvIEJBU0VfSEFMRiB9LFxuICAgICAgICB1SW52SGVpZ2h0OiB7IHZhbHVlOiAxIC8gSCB9LFxuICAgICAgICB1TWluQXhpczogeyB2YWx1ZTogTWF0aC5taW4oQkFTRV9IQUxGLCBIKSB9LFxuICAgICAgICB1UHhTY2FsZToge1xuICAgICAgICAgIHZhbHVlOiAxIC8gKChnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IHx8IDEpICogMC4xICogU0NBTEUpLFxuICAgICAgICB9LFxuICAgICAgICB1VGltZVNjYWxlOiB7IHZhbHVlOiBUUyB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2wsIHsgZ2VvbWV0cnksIHByb2dyYW0gfSk7XG5cbiAgICBjb25zdCByZXNpemUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDE7XG4gICAgICBjb25zdCBoID0gY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAxO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3LCBoKTtcbiAgICAgIGlSZXNCdWZbMF0gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gICAgICBpUmVzQnVmWzFdID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgICAgIG9mZnNldFB4QnVmWzBdID0gb2ZmWCAqIGRwcjtcbiAgICAgIG9mZnNldFB4QnVmWzFdID0gb2ZmWSAqIGRwcjtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMudVB4U2NhbGUudmFsdWUgPVxuICAgICAgICAxIC8gKChnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IHx8IDEpICogMC4xICogU0NBTEUpO1xuICAgIH07XG4gICAgY29uc3Qgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIocmVzaXplKTtcbiAgICByby5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgcmVzaXplKCk7XG5cbiAgICBjb25zdCByb3RCdWYgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgIGNvbnN0IHNldE1hdDNGcm9tRXVsZXIgPSAoXG4gICAgICB5YXdZOiBudW1iZXIsXG4gICAgICBwaXRjaFg6IG51bWJlcixcbiAgICAgIHJvbGxaOiBudW1iZXIsXG4gICAgICBvdXQ6IEZsb2F0MzJBcnJheVxuICAgICkgPT4ge1xuICAgICAgY29uc3QgY3kgPSBNYXRoLmNvcyh5YXdZKSxcbiAgICAgICAgc3kgPSBNYXRoLnNpbih5YXdZKTtcbiAgICAgIGNvbnN0IGN4ID0gTWF0aC5jb3MocGl0Y2hYKSxcbiAgICAgICAgc3ggPSBNYXRoLnNpbihwaXRjaFgpO1xuICAgICAgY29uc3QgY3ogPSBNYXRoLmNvcyhyb2xsWiksXG4gICAgICAgIHN6ID0gTWF0aC5zaW4ocm9sbFopO1xuICAgICAgY29uc3QgcjAwID0gY3kgKiBjeiArIHN5ICogc3ggKiBzejtcbiAgICAgIGNvbnN0IHIwMSA9IC1jeSAqIHN6ICsgc3kgKiBzeCAqIGN6O1xuICAgICAgY29uc3QgcjAyID0gc3kgKiBjeDtcblxuICAgICAgY29uc3QgcjEwID0gY3ggKiBzejtcbiAgICAgIGNvbnN0IHIxMSA9IGN4ICogY3o7XG4gICAgICBjb25zdCByMTIgPSAtc3g7XG5cbiAgICAgIGNvbnN0IHIyMCA9IC1zeSAqIGN6ICsgY3kgKiBzeCAqIHN6O1xuICAgICAgY29uc3QgcjIxID0gc3kgKiBzeiArIGN5ICogc3ggKiBjejtcbiAgICAgIGNvbnN0IHIyMiA9IGN5ICogY3g7XG5cbiAgICAgIG91dFswXSA9IHIwMDtcbiAgICAgIG91dFsxXSA9IHIxMDtcbiAgICAgIG91dFsyXSA9IHIyMDtcbiAgICAgIG91dFszXSA9IHIwMTtcbiAgICAgIG91dFs0XSA9IHIxMTtcbiAgICAgIG91dFs1XSA9IHIyMTtcbiAgICAgIG91dFs2XSA9IHIwMjtcbiAgICAgIG91dFs3XSA9IHIxMjtcbiAgICAgIG91dFs4XSA9IHIyMjtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIGNvbnN0IE5PSVNFX0lTX1pFUk8gPSBOT0lTRSA8IDFlLTY7XG4gICAgbGV0IHJhZiA9IDA7XG4gICAgY29uc3QgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGFydFJBRiA9ICgpID0+IHtcbiAgICAgIGlmIChyYWYpIHJldHVybjtcbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH07XG4gICAgY29uc3Qgc3RvcFJBRiA9ICgpID0+IHtcbiAgICAgIGlmICghcmFmKSByZXR1cm47XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgcmFmID0gMDtcbiAgICB9O1xuXG4gICAgY29uc3Qgcm5kID0gKCkgPT4gTWF0aC5yYW5kb20oKTtcbiAgICBjb25zdCB3WCA9ICgwLjMgKyBybmQoKSAqIDAuNikgKiBSU1g7XG4gICAgY29uc3Qgd1kgPSAoMC4yICsgcm5kKCkgKiAwLjcpICogUlNZO1xuICAgIGNvbnN0IHdaID0gKDAuMSArIHJuZCgpICogMC41KSAqIFJTWjtcbiAgICBjb25zdCBwaFggPSBybmQoKSAqIE1hdGguUEkgKiAyO1xuICAgIGNvbnN0IHBoWiA9IHJuZCgpICogTWF0aC5QSSAqIDI7XG5cbiAgICBsZXQgeWF3ID0gMCxcbiAgICAgIHBpdGNoID0gMCxcbiAgICAgIHJvbGwgPSAwO1xuICAgIGxldCB0YXJnZXRZYXcgPSAwLFxuICAgICAgdGFyZ2V0UGl0Y2ggPSAwO1xuICAgIGNvbnN0IGxlcnAgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcikgPT4gYSArIChiIC0gYSkgKiB0O1xuXG4gICAgY29uc3QgcG9pbnRlciA9IHsgeDogMCwgeTogMCwgaW5zaWRlOiB0cnVlIH07XG4gICAgY29uc3Qgb25Nb3ZlID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgY29uc3Qgd3cgPSBNYXRoLm1heCgxLCB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgICBjb25zdCB3aCA9IE1hdGgubWF4KDEsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjb25zdCBjeCA9IHd3ICogMC41O1xuICAgICAgY29uc3QgY3kgPSB3aCAqIDAuNTtcbiAgICAgIGNvbnN0IG54ID0gKGUuY2xpZW50WCAtIGN4KSAvICh3dyAqIDAuNSk7XG4gICAgICBjb25zdCBueSA9IChlLmNsaWVudFkgLSBjeSkgLyAod2ggKiAwLjUpO1xuICAgICAgcG9pbnRlci54ID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIG54KSk7XG4gICAgICBwb2ludGVyLnkgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgbnkpKTtcbiAgICAgIHBvaW50ZXIuaW5zaWRlID0gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTGVhdmUgPSAoKSA9PiB7XG4gICAgICBwb2ludGVyLmluc2lkZSA9IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3Qgb25CbHVyID0gKCkgPT4ge1xuICAgICAgcG9pbnRlci5pbnNpZGUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IG9uUG9pbnRlck1vdmU6ICgoZTogUG9pbnRlckV2ZW50KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25UeXBlID09PSBcImhvdmVyXCIpIHtcbiAgICAgIG9uUG9pbnRlck1vdmUgPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICAgIG9uTW92ZShlKTtcbiAgICAgICAgc3RhcnRSQUYoKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBvbkxlYXZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbkJsdXIpO1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51VXNlQmFzZVdvYmJsZS52YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChhbmltYXRpb25UeXBlID09PSBcIjNkcm90YXRlXCIpIHtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMudVVzZUJhc2VXb2JibGUudmFsdWUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLnVVc2VCYXNlV29iYmxlLnZhbHVlID0gMTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXIgPSAodDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCB0aW1lID0gKHQgLSB0MCkgKiAwLjAwMTtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaVRpbWUudmFsdWUgPSB0aW1lO1xuXG4gICAgICBsZXQgY29udGludWVSQUYgPSB0cnVlO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJob3ZlclwiKSB7XG4gICAgICAgIGNvbnN0IG1heFBpdGNoID0gMC42ICogSE9WU1RSO1xuICAgICAgICBjb25zdCBtYXhZYXcgPSAwLjYgKiBIT1ZTVFI7XG4gICAgICAgIHRhcmdldFlhdyA9IChwb2ludGVyLmluc2lkZSA/IC1wb2ludGVyLnggOiAwKSAqIG1heFlhdztcbiAgICAgICAgdGFyZ2V0UGl0Y2ggPSAocG9pbnRlci5pbnNpZGUgPyBwb2ludGVyLnkgOiAwKSAqIG1heFBpdGNoO1xuICAgICAgICBjb25zdCBwcmV2WWF3ID0geWF3O1xuICAgICAgICBjb25zdCBwcmV2UGl0Y2ggPSBwaXRjaDtcbiAgICAgICAgY29uc3QgcHJldlJvbGwgPSByb2xsO1xuICAgICAgICB5YXcgPSBsZXJwKHByZXZZYXcsIHRhcmdldFlhdywgSU5FUlQpO1xuICAgICAgICBwaXRjaCA9IGxlcnAocHJldlBpdGNoLCB0YXJnZXRQaXRjaCwgSU5FUlQpO1xuICAgICAgICByb2xsID0gbGVycChwcmV2Um9sbCwgMCwgMC4xKTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51Um90LnZhbHVlID0gc2V0TWF0M0Zyb21FdWxlcihcbiAgICAgICAgICB5YXcsXG4gICAgICAgICAgcGl0Y2gsXG4gICAgICAgICAgcm9sbCxcbiAgICAgICAgICByb3RCdWZcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoTk9JU0VfSVNfWkVSTykge1xuICAgICAgICAgIGNvbnN0IHNldHRsZWQgPVxuICAgICAgICAgICAgTWF0aC5hYnMoeWF3IC0gdGFyZ2V0WWF3KSA8IDFlLTQgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHBpdGNoIC0gdGFyZ2V0UGl0Y2gpIDwgMWUtNCAmJlxuICAgICAgICAgICAgTWF0aC5hYnMocm9sbCkgPCAxZS00O1xuICAgICAgICAgIGlmIChzZXR0bGVkKSBjb250aW51ZVJBRiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwiM2Ryb3RhdGVcIikge1xuICAgICAgICBjb25zdCB0U2NhbGVkID0gdGltZSAqIFRTO1xuICAgICAgICB5YXcgPSB0U2NhbGVkICogd1k7XG4gICAgICAgIHBpdGNoID0gTWF0aC5zaW4odFNjYWxlZCAqIHdYICsgcGhYKSAqIDAuNjtcbiAgICAgICAgcm9sbCA9IE1hdGguc2luKHRTY2FsZWQgKiB3WiArIHBoWikgKiAwLjU7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybXMudVJvdC52YWx1ZSA9IHNldE1hdDNGcm9tRXVsZXIoXG4gICAgICAgICAgeWF3LFxuICAgICAgICAgIHBpdGNoLFxuICAgICAgICAgIHJvbGwsXG4gICAgICAgICAgcm90QnVmXG4gICAgICAgICk7XG4gICAgICAgIGlmIChUUyA8IDFlLTYpIGNvbnRpbnVlUkFGID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RCdWZbMF0gPSAxO1xuICAgICAgICByb3RCdWZbMV0gPSAwO1xuICAgICAgICByb3RCdWZbMl0gPSAwO1xuICAgICAgICByb3RCdWZbM10gPSAwO1xuICAgICAgICByb3RCdWZbNF0gPSAxO1xuICAgICAgICByb3RCdWZbNV0gPSAwO1xuICAgICAgICByb3RCdWZbNl0gPSAwO1xuICAgICAgICByb3RCdWZbN10gPSAwO1xuICAgICAgICByb3RCdWZbOF0gPSAxO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm1zLnVSb3QudmFsdWUgPSByb3RCdWY7XG4gICAgICAgIGlmIChUUyA8IDFlLTYpIGNvbnRpbnVlUkFGID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlcih7IHNjZW5lOiBtZXNoIH0pO1xuICAgICAgaWYgKGNvbnRpbnVlUkFGKSB7XG4gICAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFmID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW50ZXJmYWNlIFByaXNtQ29udGFpbmVyIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgX19wcmlzbUlPPzogSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbmRXaGVuT2Zmc2NyZWVuKSB7XG4gICAgICBjb25zdCBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBjb25zdCB2aXMgPSBlbnRyaWVzLnNvbWUoKGUpID0+IGUuaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICBpZiAodmlzKSBzdGFydFJBRigpO1xuICAgICAgICBlbHNlIHN0b3BSQUYoKTtcbiAgICAgIH0pO1xuICAgICAgaW8ub2JzZXJ2ZShjb250YWluZXIpO1xuICAgICAgc3RhcnRSQUYoKTtcbiAgICAgIChjb250YWluZXIgYXMgUHJpc21Db250YWluZXIpLl9fcHJpc21JTyA9IGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJBRigpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdG9wUkFGKCk7XG4gICAgICByby5kaXNjb25uZWN0KCk7XG4gICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJob3ZlclwiKSB7XG4gICAgICAgIGlmIChvblBvaW50ZXJNb3ZlKVxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJwb2ludGVybW92ZVwiLFxuICAgICAgICAgICAgb25Qb2ludGVyTW92ZSBhcyBFdmVudExpc3RlbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgb25CbHVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5kV2hlbk9mZnNjcmVlbikge1xuICAgICAgICBjb25zdCBpbyA9IChjb250YWluZXIgYXMgUHJpc21Db250YWluZXIpLl9fcHJpc21JTyBhc1xuICAgICAgICAgIHwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlvKSBpby5kaXNjb25uZWN0KCk7XG4gICAgICAgIGRlbGV0ZSAoY29udGFpbmVyIGFzIFByaXNtQ29udGFpbmVyKS5fX3ByaXNtSU87XG4gICAgICB9XG4gICAgICBpZiAoZ2wuY2FudmFzLnBhcmVudEVsZW1lbnQgPT09IGNvbnRhaW5lcilcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGdsLmNhbnZhcyk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGdsb3csXG4gICAgbm9pc2UsXG4gICAgc2NhbGUsXG4gICAgYmxvb20sXG4gICAgaGVpZ2h0LFxuICAgIGluZXJ0aWEsXG4gICAgaHVlU2hpZnQsXG4gICAgYmFzZVdpZHRoLFxuICAgIG9mZnNldD8ueCxcbiAgICBvZmZzZXQ/LnksXG4gICAgdGltZVNjYWxlLFxuICAgIHRyYW5zcGFyZW50LFxuICAgIGFuaW1hdGlvblR5cGUsXG4gICAgaG92ZXJTdHJlbmd0aCxcbiAgICBjb2xvckZyZXF1ZW5jeSxcbiAgICBzdXNwZW5kV2hlbk9mZnNjcmVlbixcbiAgXSk7XG5cbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBhYnNvbHV0ZVwiIHJlZj17Y29udGFpbmVyUmVmfSAvPjtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJNZXNoIiwiUHJvZ3JhbSIsIlJlbmRlcmVyIiwiVHJpYW5nbGUiLCJQcmlzbSIsImdsb3ciLCJibG9vbSIsIm5vaXNlIiwic2NhbGUiLCJoZWlnaHQiLCJodWVTaGlmdCIsImluZXJ0aWEiLCJiYXNlV2lkdGgiLCJ0aW1lU2NhbGUiLCJob3ZlclN0cmVuZ3RoIiwidHJhbnNwYXJlbnQiLCJjb2xvckZyZXF1ZW5jeSIsIm9mZnNldCIsIngiLCJ5IiwiYW5pbWF0aW9uVHlwZSIsInN1c3BlbmRXaGVuT2Zmc2NyZWVuIiwiY29udGFpbmVyUmVmIiwiY29udGFpbmVyIiwiY3VycmVudCIsIkgiLCJNYXRoIiwibWF4IiwiQlciLCJCQVNFX0hBTEYiLCJHTE9XIiwiTk9JU0UiLCJvZmZYIiwib2ZmWSIsIlNBVCIsIlNDQUxFIiwiSFVFIiwiQ0ZSRVEiLCJCTE9PTSIsIlJTWCIsIlJTWSIsIlJTWiIsIlRTIiwiSE9WU1RSIiwiSU5FUlQiLCJtaW4iLCJkcHIiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwicmVuZGVyZXIiLCJhbHBoYSIsImFudGlhbGlhcyIsImdsIiwiZGlzYWJsZSIsIkRFUFRIX1RFU1QiLCJDVUxMX0ZBQ0UiLCJCTEVORCIsIk9iamVjdCIsImFzc2lnbiIsImNhbnZhcyIsInN0eWxlIiwicG9zaXRpb24iLCJpbnNldCIsIndpZHRoIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwidmVydGV4IiwiZnJhZ21lbnQiLCJnZW9tZXRyeSIsImlSZXNCdWYiLCJGbG9hdDMyQXJyYXkiLCJvZmZzZXRQeEJ1ZiIsInByb2dyYW0iLCJ1bmlmb3JtcyIsImlSZXNvbHV0aW9uIiwidmFsdWUiLCJpVGltZSIsInVIZWlnaHQiLCJ1QmFzZUhhbGYiLCJ1VXNlQmFzZVdvYmJsZSIsInVSb3QiLCJ1R2xvdyIsInVPZmZzZXRQeCIsInVOb2lzZSIsInVTYXR1cmF0aW9uIiwidVNjYWxlIiwidUh1ZVNoaWZ0IiwidUNvbG9yRnJlcSIsInVCbG9vbSIsInVDZW50ZXJTaGlmdCIsInVJbnZCYXNlSGFsZiIsInVJbnZIZWlnaHQiLCJ1TWluQXhpcyIsInVQeFNjYWxlIiwiZHJhd2luZ0J1ZmZlckhlaWdodCIsInVUaW1lU2NhbGUiLCJtZXNoIiwicmVzaXplIiwidyIsImNsaWVudFdpZHRoIiwiaCIsImNsaWVudEhlaWdodCIsInNldFNpemUiLCJkcmF3aW5nQnVmZmVyV2lkdGgiLCJybyIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInJvdEJ1ZiIsInNldE1hdDNGcm9tRXVsZXIiLCJ5YXdZIiwicGl0Y2hYIiwicm9sbFoiLCJvdXQiLCJjeSIsImNvcyIsInN5Iiwic2luIiwiY3giLCJzeCIsImN6Iiwic3oiLCJyMDAiLCJyMDEiLCJyMDIiLCJyMTAiLCJyMTEiLCJyMTIiLCJyMjAiLCJyMjEiLCJyMjIiLCJOT0lTRV9JU19aRVJPIiwicmFmIiwidDAiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInN0YXJ0UkFGIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyIiwic3RvcFJBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicm5kIiwicmFuZG9tIiwid1giLCJ3WSIsIndaIiwicGhYIiwiUEkiLCJwaFoiLCJ5YXciLCJwaXRjaCIsInJvbGwiLCJ0YXJnZXRZYXciLCJ0YXJnZXRQaXRjaCIsImxlcnAiLCJhIiwiYiIsInQiLCJwb2ludGVyIiwiaW5zaWRlIiwib25Nb3ZlIiwiZSIsInd3IiwiaW5uZXJXaWR0aCIsIndoIiwiaW5uZXJIZWlnaHQiLCJueCIsImNsaWVudFgiLCJueSIsImNsaWVudFkiLCJvbkxlYXZlIiwib25CbHVyIiwib25Qb2ludGVyTW92ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwidGltZSIsImNvbnRpbnVlUkFGIiwibWF4UGl0Y2giLCJtYXhZYXciLCJwcmV2WWF3IiwicHJldlBpdGNoIiwicHJldlJvbGwiLCJzZXR0bGVkIiwiYWJzIiwidFNjYWxlZCIsInNjZW5lIiwiaW8iLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJ2aXMiLCJzb21lIiwiaXNJbnRlcnNlY3RpbmciLCJfX3ByaXNtSU8iLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsImRpdiIsImNsYXNzTmFtZSIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/ui/prisma-background/index.tsx\n"));

/***/ })

});