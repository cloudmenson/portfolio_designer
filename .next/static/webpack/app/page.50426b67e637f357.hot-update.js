"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/shared/ui/prisma-background/index.tsx":
/*!***************************************************!*\
  !*** ./src/shared/ui/prisma-background/index.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Prism: () => (/* binding */ Prism)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Prism = (param)=>{\n    let { glow = 1, bloom = 3222, noise = 0.1, scale = 3.6, height = 3.5, hueShift = 0, inertia = 0.05, baseWidth = 5.5, timeScale = 0.5, hoverStrength = 2, transparent = true, colorFrequency = 1, offset = {\n        x: 0,\n        y: 0\n    }, animationType = \"rotate\", suspendWhenOffscreen = false } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Prism.useEffect\": ()=>{\n            const container = containerRef.current;\n            if (!container) return;\n            const H = Math.max(0.001, height);\n            const BW = Math.max(0.001, baseWidth);\n            const BASE_HALF = BW * 0.5;\n            const GLOW = Math.max(0.0, glow);\n            const NOISE = Math.max(0.0, noise);\n            var _offset_x;\n            const offX = (_offset_x = offset === null || offset === void 0 ? void 0 : offset.x) !== null && _offset_x !== void 0 ? _offset_x : 0;\n            var _offset_y;\n            const offY = (_offset_y = offset === null || offset === void 0 ? void 0 : offset.y) !== null && _offset_y !== void 0 ? _offset_y : 0;\n            const SAT = transparent ? 1.5 : 1;\n            const SCALE = Math.max(0.001, scale);\n            const HUE = hueShift || 0;\n            const CFREQ = Math.max(0.0, colorFrequency || 1);\n            const BLOOM = Math.max(0.0, bloom || 1);\n            const RSX = 1;\n            const RSY = 1;\n            const RSZ = 1;\n            const TS = Math.max(0, timeScale || 1);\n            const HOVSTR = Math.max(0, hoverStrength || 1);\n            const INERT = Math.max(0, Math.min(1, inertia || 0.12));\n            const dpr = Math.min(2, window.devicePixelRatio || 1);\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_2__.Renderer({\n                dpr,\n                alpha: transparent,\n                antialias: false\n            });\n            const gl = renderer.gl;\n            gl.disable(gl.DEPTH_TEST);\n            gl.disable(gl.CULL_FACE);\n            gl.disable(gl.BLEND);\n            Object.assign(gl.canvas.style, {\n                position: \"absolute\",\n                inset: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                display: \"block\"\n            });\n            container.appendChild(gl.canvas);\n            const vertex = \"\\n      attribute vec2 position;\\n      void main() {\\n        gl_Position = vec4(position, 0.0, 1.0);\\n      }\\n    \";\n            const fragment = \"\\n      precision highp float;\\n\\n      uniform vec2  iResolution;\\n      uniform float iTime;\\n\\n      uniform float uHeight;\\n      uniform float uBaseHalf;\\n      uniform mat3  uRot;\\n      uniform int   uUseBaseWobble;\\n      uniform float uGlow;\\n      uniform vec2  uOffsetPx;\\n      uniform float uNoise;\\n      uniform float uSaturation;\\n      uniform float uScale;\\n      uniform float uHueShift;\\n      uniform float uColorFreq;\\n      uniform float uBloom;\\n      uniform float uCenterShift;\\n      uniform float uInvBaseHalf;\\n      uniform float uInvHeight;\\n      uniform float uMinAxis;\\n      uniform float uPxScale;\\n      uniform float uTimeScale;\\n\\n      vec4 tanh4(vec4 x){\\n        vec4 e2x = exp(2.0*x);\\n        return (e2x - 1.0) / (e2x + 1.0);\\n      }\\n\\n      float rand(vec2 co){\\n        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\\n      }\\n\\n      float sdOctaAnisoInv(vec3 p){\\n        vec3 q = vec3(abs(p.x) * uInvBaseHalf, abs(p.y) * uInvHeight, abs(p.z) * uInvBaseHalf);\\n        float m = q.x + q.y + q.z - 1.0;\\n        return m * uMinAxis * 0.5773502691896258;\\n      }\\n\\n      float sdPyramidUpInv(vec3 p){\\n        float oct = sdOctaAnisoInv(p);\\n        float halfSpace = -p.y;\\n        return max(oct, halfSpace);\\n      }\\n\\n      mat3 hueRotation(float a){\\n        float c = cos(a), s = sin(a);\\n        mat3 W = mat3(\\n          0.299, 0.587, 0.114,\\n          0.299, 0.587, 0.114,\\n          0.299, 0.587, 0.114\\n        );\\n        mat3 U = mat3(\\n           0.701, -0.587, -0.114,\\n          -0.299,  0.413, -0.114,\\n          -0.300, -0.588,  0.886\\n        );\\n        mat3 V = mat3(\\n           0.168, -0.331,  0.500,\\n           0.328,  0.035, -0.500,\\n          -0.497,  0.296,  0.201\\n        );\\n        return W + U * c + V * s;\\n      }\\n\\n      void main(){\\n        vec2 f = (gl_FragCoord.xy - 0.5 * iResolution.xy - uOffsetPx) * uPxScale;\\n\\n        float z = 5.0;\\n        float d = 0.0;\\n\\n        vec3 p;\\n        vec4 o = vec4(0.0);\\n\\n        float centerShift = uCenterShift;\\n        float cf = uColorFreq;\\n\\n        mat2 wob = mat2(1.0);\\n        if (uUseBaseWobble == 1) {\\n          float t = iTime * uTimeScale;\\n          float c0 = cos(t + 0.0);\\n          float c1 = cos(t + 33.0);\\n          float c2 = cos(t + 11.0);\\n          wob = mat2(c0, c1, c2, c0);\\n        }\\n\\n        const int STEPS = 100;\\n        for (int i = 0; i < STEPS; i++) {\\n          p = vec3(f, z);\\n          p.xz = p.xz * wob;\\n          p = uRot * p;\\n          vec3 q = p;\\n          q.y += centerShift;\\n          d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));\\n          z -= d;\\n          o += (sin((p.y + z) * cf + vec4(0.0, 1.0, 2.0, 3.0)) + 1.0) / d;\\n        }\\n\\n        o = tanh4(o * o * (uGlow * uBloom) / 1e5);\\n\\n        vec3 col = o.rgb;\\n        float n = rand(gl_FragCoord.xy + vec2(iTime));\\n        col += (n - 0.5) * uNoise;\\n        col = clamp(col, 0.0, 1.0);\\n\\n        float L = dot(col, vec3(0.2126, 0.7152, 0.0722));\\n        col = clamp(mix(vec3(L), col, uSaturation), 0.0, 1.0);\\n\\n        if(abs(uHueShift) > 0.0001){\\n          col = clamp(hueRotation(uHueShift) * col, 0.0, 1.0);\\n        }\\n\\n        gl_FragColor = vec4(col, o.a);\\n      }\\n    \";\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_3__.Triangle(gl);\n            const iResBuf = new Float32Array(2);\n            const offsetPxBuf = new Float32Array(2);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_4__.Program(gl, {\n                vertex,\n                fragment,\n                uniforms: {\n                    iResolution: {\n                        value: iResBuf\n                    },\n                    iTime: {\n                        value: 0\n                    },\n                    uHeight: {\n                        value: H\n                    },\n                    uBaseHalf: {\n                        value: BASE_HALF\n                    },\n                    uUseBaseWobble: {\n                        value: 1\n                    },\n                    uRot: {\n                        value: new Float32Array([\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1\n                        ])\n                    },\n                    uGlow: {\n                        value: GLOW\n                    },\n                    uOffsetPx: {\n                        value: offsetPxBuf\n                    },\n                    uNoise: {\n                        value: NOISE\n                    },\n                    uSaturation: {\n                        value: SAT\n                    },\n                    uScale: {\n                        value: SCALE\n                    },\n                    uHueShift: {\n                        value: HUE\n                    },\n                    uColorFreq: {\n                        value: CFREQ\n                    },\n                    uBloom: {\n                        value: BLOOM\n                    },\n                    uCenterShift: {\n                        value: H * 0.25\n                    },\n                    uInvBaseHalf: {\n                        value: 1 / BASE_HALF\n                    },\n                    uInvHeight: {\n                        value: 1 / H\n                    },\n                    uMinAxis: {\n                        value: Math.min(BASE_HALF, H)\n                    },\n                    uPxScale: {\n                        value: 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE)\n                    },\n                    uTimeScale: {\n                        value: TS\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_5__.Mesh(gl, {\n                geometry,\n                program\n            });\n            const resize = {\n                \"Prism.useEffect.resize\": ()=>{\n                    const w = container.clientWidth || 1;\n                    const h = container.clientHeight || 1;\n                    renderer.setSize(w, h);\n                    iResBuf[0] = gl.drawingBufferWidth;\n                    iResBuf[1] = gl.drawingBufferHeight;\n                    offsetPxBuf[0] = offX * dpr;\n                    offsetPxBuf[1] = offY * dpr;\n                    program.uniforms.uPxScale.value = 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE);\n                }\n            }[\"Prism.useEffect.resize\"];\n            const ro = new ResizeObserver(resize);\n            ro.observe(container);\n            resize();\n            const rotBuf = new Float32Array(9);\n            const setMat3FromEuler = {\n                \"Prism.useEffect.setMat3FromEuler\": (yawY, pitchX, rollZ, out)=>{\n                    const cy = Math.cos(yawY), sy = Math.sin(yawY);\n                    const cx = Math.cos(pitchX), sx = Math.sin(pitchX);\n                    const cz = Math.cos(rollZ), sz = Math.sin(rollZ);\n                    const r00 = cy * cz + sy * sx * sz;\n                    const r01 = -cy * sz + sy * sx * cz;\n                    const r02 = sy * cx;\n                    const r10 = cx * sz;\n                    const r11 = cx * cz;\n                    const r12 = -sx;\n                    const r20 = -sy * cz + cy * sx * sz;\n                    const r21 = sy * sz + cy * sx * cz;\n                    const r22 = cy * cx;\n                    out[0] = r00;\n                    out[1] = r10;\n                    out[2] = r20;\n                    out[3] = r01;\n                    out[4] = r11;\n                    out[5] = r21;\n                    out[6] = r02;\n                    out[7] = r12;\n                    out[8] = r22;\n                    return out;\n                }\n            }[\"Prism.useEffect.setMat3FromEuler\"];\n            const NOISE_IS_ZERO = NOISE < 1e-6;\n            let raf = 0;\n            const t0 = performance.now();\n            const startRAF = {\n                \"Prism.useEffect.startRAF\": ()=>{\n                    if (raf) return;\n                    raf = requestAnimationFrame(render);\n                }\n            }[\"Prism.useEffect.startRAF\"];\n            const stopRAF = {\n                \"Prism.useEffect.stopRAF\": ()=>{\n                    if (!raf) return;\n                    cancelAnimationFrame(raf);\n                    raf = 0;\n                }\n            }[\"Prism.useEffect.stopRAF\"];\n            const rnd = {\n                \"Prism.useEffect.rnd\": ()=>Math.random()\n            }[\"Prism.useEffect.rnd\"];\n            const wX = (0.3 + rnd() * 0.6) * RSX;\n            const wY = (0.2 + rnd() * 0.7) * RSY;\n            const wZ = (0.1 + rnd() * 0.5) * RSZ;\n            const phX = rnd() * Math.PI * 2;\n            const phZ = rnd() * Math.PI * 2;\n            let yaw = 0, pitch = 0, roll = 0;\n            let targetYaw = 0, targetPitch = 0;\n            const lerp = {\n                \"Prism.useEffect.lerp\": (a, b, t)=>a + (b - a) * t\n            }[\"Prism.useEffect.lerp\"];\n            const pointer = {\n                x: 0,\n                y: 0,\n                inside: true\n            };\n            const onMove = {\n                \"Prism.useEffect.onMove\": (e)=>{\n                    const ww = Math.max(1, window.innerWidth);\n                    const wh = Math.max(1, window.innerHeight);\n                    const cx = ww * 0.5;\n                    const cy = wh * 0.5;\n                    const nx = (e.clientX - cx) / (ww * 0.5);\n                    const ny = (e.clientY - cy) / (wh * 0.5);\n                    pointer.x = Math.max(-1, Math.min(1, nx));\n                    pointer.y = Math.max(-1, Math.min(1, ny));\n                    pointer.inside = true;\n                }\n            }[\"Prism.useEffect.onMove\"];\n            const onLeave = {\n                \"Prism.useEffect.onLeave\": ()=>{\n                    pointer.inside = false;\n                }\n            }[\"Prism.useEffect.onLeave\"];\n            const onBlur = {\n                \"Prism.useEffect.onBlur\": ()=>{\n                    pointer.inside = false;\n                }\n            }[\"Prism.useEffect.onBlur\"];\n            let onPointerMove = null;\n            if (animationType === \"hover\") {\n                onPointerMove = ({\n                    \"Prism.useEffect\": (e)=>{\n                        onMove(e);\n                        startRAF();\n                    }\n                })[\"Prism.useEffect\"];\n                window.addEventListener(\"pointermove\", onPointerMove, {\n                    passive: true\n                });\n                window.addEventListener(\"mouseleave\", onLeave);\n                window.addEventListener(\"blur\", onBlur);\n                program.uniforms.uUseBaseWobble.value = 0;\n            } else if (animationType === \"3drotate\") {\n                program.uniforms.uUseBaseWobble.value = 0;\n            } else {\n                program.uniforms.uUseBaseWobble.value = 1;\n            }\n            const render = {\n                \"Prism.useEffect.render\": (t)=>{\n                    const time = (t - t0) * 0.001;\n                    program.uniforms.iTime.value = time;\n                    let continueRAF = true;\n                    if (animationType === \"hover\") {\n                        const maxPitch = 0.6 * HOVSTR;\n                        const maxYaw = 0.6 * HOVSTR;\n                        targetYaw = (pointer.inside ? -pointer.x : 0) * maxYaw;\n                        targetPitch = (pointer.inside ? pointer.y : 0) * maxPitch;\n                        const prevYaw = yaw;\n                        const prevPitch = pitch;\n                        const prevRoll = roll;\n                        yaw = lerp(prevYaw, targetYaw, INERT);\n                        pitch = lerp(prevPitch, targetPitch, INERT);\n                        roll = lerp(prevRoll, 0, 0.1);\n                        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n                        if (NOISE_IS_ZERO) {\n                            const settled = Math.abs(yaw - targetYaw) < 1e-4 && Math.abs(pitch - targetPitch) < 1e-4 && Math.abs(roll) < 1e-4;\n                            if (settled) continueRAF = false;\n                        }\n                    } else if (animationType === \"3drotate\") {\n                        const tScaled = time * TS;\n                        yaw = tScaled * wY;\n                        pitch = Math.sin(tScaled * wX + phX) * 0.6;\n                        roll = Math.sin(tScaled * wZ + phZ) * 0.5;\n                        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n                        if (TS < 1e-6) continueRAF = false;\n                    } else {\n                        rotBuf[0] = 1;\n                        rotBuf[1] = 0;\n                        rotBuf[2] = 0;\n                        rotBuf[3] = 0;\n                        rotBuf[4] = 1;\n                        rotBuf[5] = 0;\n                        rotBuf[6] = 0;\n                        rotBuf[7] = 0;\n                        rotBuf[8] = 1;\n                        program.uniforms.uRot.value = rotBuf;\n                        if (TS < 1e-6) continueRAF = false;\n                    }\n                    renderer.render({\n                        scene: mesh\n                    });\n                    if (continueRAF) {\n                        raf = requestAnimationFrame(render);\n                    } else {\n                        raf = 0;\n                    }\n                }\n            }[\"Prism.useEffect.render\"];\n            if (suspendWhenOffscreen) {\n                const io = new IntersectionObserver({\n                    \"Prism.useEffect\": (entries)=>{\n                        const vis = entries.some({\n                            \"Prism.useEffect.vis\": (e)=>e.isIntersecting\n                        }[\"Prism.useEffect.vis\"]);\n                        if (vis) startRAF();\n                        else stopRAF();\n                    }\n                }[\"Prism.useEffect\"]);\n                io.observe(container);\n                startRAF();\n                container.__prismIO = io;\n            } else {\n                startRAF();\n            }\n            return ({\n                \"Prism.useEffect\": ()=>{\n                    stopRAF();\n                    ro.disconnect();\n                    if (animationType === \"hover\") {\n                        if (onPointerMove) window.removeEventListener(\"pointermove\", onPointerMove);\n                        window.removeEventListener(\"mouseleave\", onLeave);\n                        window.removeEventListener(\"blur\", onBlur);\n                    }\n                    if (suspendWhenOffscreen) {\n                        const io = container.__prismIO;\n                        if (io) io.disconnect();\n                        delete container.__prismIO;\n                    }\n                    if (gl.canvas.parentElement === container) container.removeChild(gl.canvas);\n                }\n            })[\"Prism.useEffect\"];\n        }\n    }[\"Prism.useEffect\"], [\n        glow,\n        noise,\n        scale,\n        bloom,\n        height,\n        inertia,\n        hueShift,\n        baseWidth,\n        offset === null || offset === void 0 ? void 0 : offset.x,\n        offset === null || offset === void 0 ? void 0 : offset.y,\n        timeScale,\n        transparent,\n        animationType,\n        hoverStrength,\n        colorFrequency,\n        suspendWhenOffscreen\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full absolute\",\n        ref: containerRef\n    }, void 0, false, {\n        fileName: \"/Users/cloudmenson/Desktop/Files/Programming/My portfolio website/designer-portfolio/src/shared/ui/prisma-background/index.tsx\",\n        lineNumber: 479,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Prism, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = Prism;\nvar _c;\n$RefreshReg$(_c, \"Prism\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvdWkvcHJpc21hLWJhY2tncm91bmQvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTztBQW9CakQsTUFBTU8sUUFBOEI7UUFBQyxFQUMxQ0MsT0FBTyxDQUFDLEVBQ1JDLFFBQVEsSUFBSSxFQUNaQyxRQUFRLEdBQUcsRUFDWEMsUUFBUSxHQUFHLEVBQ1hDLFNBQVMsR0FBRyxFQUNaQyxXQUFXLENBQUMsRUFDWkMsVUFBVSxJQUFJLEVBQ2RDLFlBQVksR0FBRyxFQUNmQyxZQUFZLEdBQUcsRUFDZkMsZ0JBQWdCLENBQUMsRUFDakJDLGNBQWMsSUFBSSxFQUNsQkMsaUJBQWlCLENBQUMsRUFDbEJDLFNBQVM7UUFBRUMsR0FBRztRQUFHQyxHQUFHO0lBQUUsQ0FBQyxFQUN2QkMsZ0JBQWdCLFFBQVEsRUFDeEJDLHVCQUF1QixLQUFLLEVBQzdCOztJQUNDLE1BQU1DLGVBQWV2Qiw2Q0FBTUEsQ0FBd0I7SUFFbkRELGdEQUFTQTsyQkFBQztZQUNSLE1BQU15QixZQUFZRCxhQUFhRSxPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsV0FBVztZQUVoQixNQUFNRSxJQUFJQyxLQUFLQyxHQUFHLENBQUMsT0FBT2xCO1lBQzFCLE1BQU1tQixLQUFLRixLQUFLQyxHQUFHLENBQUMsT0FBT2Y7WUFDM0IsTUFBTWlCLFlBQVlELEtBQUs7WUFDdkIsTUFBTUUsT0FBT0osS0FBS0MsR0FBRyxDQUFDLEtBQUt0QjtZQUMzQixNQUFNMEIsUUFBUUwsS0FBS0MsR0FBRyxDQUFDLEtBQUtwQjtnQkFDZlU7WUFBYixNQUFNZSxPQUFPZixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFDLENBQUMsY0FBVEQsdUJBQUFBLFlBQWE7Z0JBQ2JBO1lBQWIsTUFBTWdCLE9BQU9oQixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFFLENBQUMsY0FBVEYsdUJBQUFBLFlBQWE7WUFDMUIsTUFBTWlCLE1B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O1FBQ0FFO1FBQ0FLO0tBQ0Q7SUFFRCxxQkFBTyw4REFBQytLO1FBQUlDLFdBQVU7UUFBeUJDLEtBQUtoTDs7Ozs7O0FBQ3RELEVBQUU7R0ExY1dsQjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2Nsb3VkbWVuc29uL0Rlc2t0b3AvRmlsZXMvUHJvZ3JhbW1pbmcvTXkgcG9ydGZvbGlvIHdlYnNpdGUvZGVzaWduZXItcG9ydGZvbGlvL3NyYy9zaGFyZWQvdWkvcHJpc21hLWJhY2tncm91bmQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTWVzaCwgUHJvZ3JhbSwgUmVuZGVyZXIsIFRyaWFuZ2xlIH0gZnJvbSBcIm9nbFwiO1xuXG50eXBlIFByaXNtUHJvcHMgPSB7XG4gIGdsb3c/OiBudW1iZXI7XG4gIG5vaXNlPzogbnVtYmVyO1xuICBzY2FsZT86IG51bWJlcjtcbiAgYmxvb20/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgaW5lcnRpYT86IG51bWJlcjtcbiAgaHVlU2hpZnQ/OiBudW1iZXI7XG4gIGJhc2VXaWR0aD86IG51bWJlcjtcbiAgdGltZVNjYWxlPzogbnVtYmVyO1xuICB0cmFuc3BhcmVudD86IGJvb2xlYW47XG4gIGhvdmVyU3RyZW5ndGg/OiBudW1iZXI7XG4gIGNvbG9yRnJlcXVlbmN5PzogbnVtYmVyO1xuICBzdXNwZW5kV2hlbk9mZnNjcmVlbj86IGJvb2xlYW47XG4gIG9mZnNldD86IHsgeD86IG51bWJlcjsgeT86IG51bWJlciB9O1xuICBhbmltYXRpb25UeXBlPzogXCJyb3RhdGVcIiB8IFwiaG92ZXJcIiB8IFwiM2Ryb3RhdGVcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBQcmlzbTogUmVhY3QuRkM8UHJpc21Qcm9wcz4gPSAoe1xuICBnbG93ID0gMSxcbiAgYmxvb20gPSAzMjIyLFxuICBub2lzZSA9IDAuMSxcbiAgc2NhbGUgPSAzLjYsXG4gIGhlaWdodCA9IDMuNSxcbiAgaHVlU2hpZnQgPSAwLFxuICBpbmVydGlhID0gMC4wNSxcbiAgYmFzZVdpZHRoID0gNS41LFxuICB0aW1lU2NhbGUgPSAwLjUsXG4gIGhvdmVyU3RyZW5ndGggPSAyLFxuICB0cmFuc3BhcmVudCA9IHRydWUsXG4gIGNvbG9yRnJlcXVlbmN5ID0gMSxcbiAgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH0sXG4gIGFuaW1hdGlvblR5cGUgPSBcInJvdGF0ZVwiLFxuICBzdXNwZW5kV2hlbk9mZnNjcmVlbiA9IGZhbHNlLFxufSkgPT4ge1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICBjb25zdCBIID0gTWF0aC5tYXgoMC4wMDEsIGhlaWdodCk7XG4gICAgY29uc3QgQlcgPSBNYXRoLm1heCgwLjAwMSwgYmFzZVdpZHRoKTtcbiAgICBjb25zdCBCQVNFX0hBTEYgPSBCVyAqIDAuNTtcbiAgICBjb25zdCBHTE9XID0gTWF0aC5tYXgoMC4wLCBnbG93KTtcbiAgICBjb25zdCBOT0lTRSA9IE1hdGgubWF4KDAuMCwgbm9pc2UpO1xuICAgIGNvbnN0IG9mZlggPSBvZmZzZXQ/LnggPz8gMDtcbiAgICBjb25zdCBvZmZZID0gb2Zmc2V0Py55ID8/IDA7XG4gICAgY29uc3QgU0FUID0gdHJhbnNwYXJlbnQgPyAxLjUgOiAxO1xuICAgIGNvbnN0IFNDQUxFID0gTWF0aC5tYXgoMC4wMDEsIHNjYWxlKTtcbiAgICBjb25zdCBIVUUgPSBodWVTaGlmdCB8fCAwO1xuICAgIGNvbnN0IENGUkVRID0gTWF0aC5tYXgoMC4wLCBjb2xvckZyZXF1ZW5jeSB8fCAxKTtcbiAgICBjb25zdCBCTE9PTSA9IE1hdGgubWF4KDAuMCwgYmxvb20gfHwgMSk7XG4gICAgY29uc3QgUlNYID0gMTtcbiAgICBjb25zdCBSU1kgPSAxO1xuICAgIGNvbnN0IFJTWiA9IDE7XG4gICAgY29uc3QgVFMgPSBNYXRoLm1heCgwLCB0aW1lU2NhbGUgfHwgMSk7XG4gICAgY29uc3QgSE9WU1RSID0gTWF0aC5tYXgoMCwgaG92ZXJTdHJlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBJTkVSVCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGluZXJ0aWEgfHwgMC4xMikpO1xuXG4gICAgY29uc3QgZHByID0gTWF0aC5taW4oMiwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgZHByLFxuICAgICAgYWxwaGE6IHRyYW5zcGFyZW50LFxuICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICB9KTtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gICAgT2JqZWN0LmFzc2lnbihnbC5jYW52YXMuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBpbnNldDogXCIwXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgIH0gYXMgUGFydGlhbDxDU1NTdHlsZURlY2xhcmF0aW9uPik7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdsLmNhbnZhcyk7XG5cbiAgICBjb25zdCB2ZXJ0ZXggPSAvKiBnbHNsICovIGBcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovIGBcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgICAgdW5pZm9ybSB2ZWMyICBpUmVzb2x1dGlvbjtcbiAgICAgIHVuaWZvcm0gZmxvYXQgaVRpbWU7XG5cbiAgICAgIHVuaWZvcm0gZmxvYXQgdUhlaWdodDtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUJhc2VIYWxmO1xuICAgICAgdW5pZm9ybSBtYXQzICB1Um90O1xuICAgICAgdW5pZm9ybSBpbnQgICB1VXNlQmFzZVdvYmJsZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUdsb3c7XG4gICAgICB1bmlmb3JtIHZlYzIgIHVPZmZzZXRQeDtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdU5vaXNlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdVNjYWxlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1SHVlU2hpZnQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVDb2xvckZyZXE7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVCbG9vbTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdUNlbnRlclNoaWZ0O1xuICAgICAgdW5pZm9ybSBmbG9hdCB1SW52QmFzZUhhbGY7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVJbnZIZWlnaHQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVNaW5BeGlzO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1UHhTY2FsZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdVRpbWVTY2FsZTtcblxuICAgICAgdmVjNCB0YW5oNCh2ZWM0IHgpe1xuICAgICAgICB2ZWM0IGUyeCA9IGV4cCgyLjAqeCk7XG4gICAgICAgIHJldHVybiAoZTJ4IC0gMS4wKSAvIChlMnggKyAxLjApO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCByYW5kKHZlYzIgY28pe1xuICAgICAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjbywgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzMTIzKTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgc2RPY3RhQW5pc29JbnYodmVjMyBwKXtcbiAgICAgICAgdmVjMyBxID0gdmVjMyhhYnMocC54KSAqIHVJbnZCYXNlSGFsZiwgYWJzKHAueSkgKiB1SW52SGVpZ2h0LCBhYnMocC56KSAqIHVJbnZCYXNlSGFsZik7XG4gICAgICAgIGZsb2F0IG0gPSBxLnggKyBxLnkgKyBxLnogLSAxLjA7XG4gICAgICAgIHJldHVybiBtICogdU1pbkF4aXMgKiAwLjU3NzM1MDI2OTE4OTYyNTg7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHNkUHlyYW1pZFVwSW52KHZlYzMgcCl7XG4gICAgICAgIGZsb2F0IG9jdCA9IHNkT2N0YUFuaXNvSW52KHApO1xuICAgICAgICBmbG9hdCBoYWxmU3BhY2UgPSAtcC55O1xuICAgICAgICByZXR1cm4gbWF4KG9jdCwgaGFsZlNwYWNlKTtcbiAgICAgIH1cblxuICAgICAgbWF0MyBodWVSb3RhdGlvbihmbG9hdCBhKXtcbiAgICAgICAgZmxvYXQgYyA9IGNvcyhhKSwgcyA9IHNpbihhKTtcbiAgICAgICAgbWF0MyBXID0gbWF0MyhcbiAgICAgICAgICAwLjI5OSwgMC41ODcsIDAuMTE0LFxuICAgICAgICAgIDAuMjk5LCAwLjU4NywgMC4xMTQsXG4gICAgICAgICAgMC4yOTksIDAuNTg3LCAwLjExNFxuICAgICAgICApO1xuICAgICAgICBtYXQzIFUgPSBtYXQzKFxuICAgICAgICAgICAwLjcwMSwgLTAuNTg3LCAtMC4xMTQsXG4gICAgICAgICAgLTAuMjk5LCAgMC40MTMsIC0wLjExNCxcbiAgICAgICAgICAtMC4zMDAsIC0wLjU4OCwgIDAuODg2XG4gICAgICAgICk7XG4gICAgICAgIG1hdDMgViA9IG1hdDMoXG4gICAgICAgICAgIDAuMTY4LCAtMC4zMzEsICAwLjUwMCxcbiAgICAgICAgICAgMC4zMjgsICAwLjAzNSwgLTAuNTAwLFxuICAgICAgICAgIC0wLjQ5NywgIDAuMjk2LCAgMC4yMDFcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIFcgKyBVICogYyArIFYgKiBzO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKXtcbiAgICAgICAgdmVjMiBmID0gKGdsX0ZyYWdDb29yZC54eSAtIDAuNSAqIGlSZXNvbHV0aW9uLnh5IC0gdU9mZnNldFB4KSAqIHVQeFNjYWxlO1xuXG4gICAgICAgIGZsb2F0IHogPSA1LjA7XG4gICAgICAgIGZsb2F0IGQgPSAwLjA7XG5cbiAgICAgICAgdmVjMyBwO1xuICAgICAgICB2ZWM0IG8gPSB2ZWM0KDAuMCk7XG5cbiAgICAgICAgZmxvYXQgY2VudGVyU2hpZnQgPSB1Q2VudGVyU2hpZnQ7XG4gICAgICAgIGZsb2F0IGNmID0gdUNvbG9yRnJlcTtcblxuICAgICAgICBtYXQyIHdvYiA9IG1hdDIoMS4wKTtcbiAgICAgICAgaWYgKHVVc2VCYXNlV29iYmxlID09IDEpIHtcbiAgICAgICAgICBmbG9hdCB0ID0gaVRpbWUgKiB1VGltZVNjYWxlO1xuICAgICAgICAgIGZsb2F0IGMwID0gY29zKHQgKyAwLjApO1xuICAgICAgICAgIGZsb2F0IGMxID0gY29zKHQgKyAzMy4wKTtcbiAgICAgICAgICBmbG9hdCBjMiA9IGNvcyh0ICsgMTEuMCk7XG4gICAgICAgICAgd29iID0gbWF0MihjMCwgYzEsIGMyLCBjMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnQgU1RFUFMgPSAxMDA7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgU1RFUFM7IGkrKykge1xuICAgICAgICAgIHAgPSB2ZWMzKGYsIHopO1xuICAgICAgICAgIHAueHogPSBwLnh6ICogd29iO1xuICAgICAgICAgIHAgPSB1Um90ICogcDtcbiAgICAgICAgICB2ZWMzIHEgPSBwO1xuICAgICAgICAgIHEueSArPSBjZW50ZXJTaGlmdDtcbiAgICAgICAgICBkID0gMC4xICsgMC4yICogYWJzKHNkUHlyYW1pZFVwSW52KHEpKTtcbiAgICAgICAgICB6IC09IGQ7XG4gICAgICAgICAgbyArPSAoc2luKChwLnkgKyB6KSAqIGNmICsgdmVjNCgwLjAsIDEuMCwgMi4wLCAzLjApKSArIDEuMCkgLyBkO1xuICAgICAgICB9XG5cbiAgICAgICAgbyA9IHRhbmg0KG8gKiBvICogKHVHbG93ICogdUJsb29tKSAvIDFlNSk7XG5cbiAgICAgICAgdmVjMyBjb2wgPSBvLnJnYjtcbiAgICAgICAgZmxvYXQgbiA9IHJhbmQoZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMihpVGltZSkpO1xuICAgICAgICBjb2wgKz0gKG4gLSAwLjUpICogdU5vaXNlO1xuICAgICAgICBjb2wgPSBjbGFtcChjb2wsIDAuMCwgMS4wKTtcblxuICAgICAgICBmbG9hdCBMID0gZG90KGNvbCwgdmVjMygwLjIxMjYsIDAuNzE1MiwgMC4wNzIyKSk7XG4gICAgICAgIGNvbCA9IGNsYW1wKG1peCh2ZWMzKEwpLCBjb2wsIHVTYXR1cmF0aW9uKSwgMC4wLCAxLjApO1xuXG4gICAgICAgIGlmKGFicyh1SHVlU2hpZnQpID4gMC4wMDAxKXtcbiAgICAgICAgICBjb2wgPSBjbGFtcChodWVSb3RhdGlvbih1SHVlU2hpZnQpICogY29sLCAwLjAsIDEuMCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbCwgby5hKTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVHJpYW5nbGUoZ2wpO1xuICAgIGNvbnN0IGlSZXNCdWYgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIGNvbnN0IG9mZnNldFB4QnVmID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwge1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpUmVzb2x1dGlvbjogeyB2YWx1ZTogaVJlc0J1ZiB9LFxuICAgICAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxuICAgICAgICB1SGVpZ2h0OiB7IHZhbHVlOiBIIH0sXG4gICAgICAgIHVCYXNlSGFsZjogeyB2YWx1ZTogQkFTRV9IQUxGIH0sXG4gICAgICAgIHVVc2VCYXNlV29iYmxlOiB7IHZhbHVlOiAxIH0sXG4gICAgICAgIHVSb3Q6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKSB9LFxuICAgICAgICB1R2xvdzogeyB2YWx1ZTogR0xPVyB9LFxuICAgICAgICB1T2Zmc2V0UHg6IHsgdmFsdWU6IG9mZnNldFB4QnVmIH0sXG4gICAgICAgIHVOb2lzZTogeyB2YWx1ZTogTk9JU0UgfSxcbiAgICAgICAgdVNhdHVyYXRpb246IHsgdmFsdWU6IFNBVCB9LFxuICAgICAgICB1U2NhbGU6IHsgdmFsdWU6IFNDQUxFIH0sXG4gICAgICAgIHVIdWVTaGlmdDogeyB2YWx1ZTogSFVFIH0sXG4gICAgICAgIHVDb2xvckZyZXE6IHsgdmFsdWU6IENGUkVRIH0sXG4gICAgICAgIHVCbG9vbTogeyB2YWx1ZTogQkxPT00gfSxcbiAgICAgICAgdUNlbnRlclNoaWZ0OiB7IHZhbHVlOiBIICogMC4yNSB9LFxuICAgICAgICB1SW52QmFzZUhhbGY6IHsgdmFsdWU6IDEgLyBCQVNFX0hBTEYgfSxcbiAgICAgICAgdUludkhlaWdodDogeyB2YWx1ZTogMSAvIEggfSxcbiAgICAgICAgdU1pbkF4aXM6IHsgdmFsdWU6IE1hdGgubWluKEJBU0VfSEFMRiwgSCkgfSxcbiAgICAgICAgdVB4U2NhbGU6IHtcbiAgICAgICAgICB2YWx1ZTogMSAvICgoZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCB8fCAxKSAqIDAuMSAqIFNDQUxFKSxcbiAgICAgICAgfSxcbiAgICAgICAgdVRpbWVTY2FsZTogeyB2YWx1ZTogVFMgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdsLCB7IGdlb21ldHJ5LCBwcm9ncmFtIH0pO1xuXG4gICAgY29uc3QgcmVzaXplID0gKCkgPT4ge1xuICAgICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAxO1xuICAgICAgY29uc3QgaCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUodywgaCk7XG4gICAgICBpUmVzQnVmWzBdID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICAgICAgaVJlc0J1ZlsxXSA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gICAgICBvZmZzZXRQeEJ1ZlswXSA9IG9mZlggKiBkcHI7XG4gICAgICBvZmZzZXRQeEJ1ZlsxXSA9IG9mZlkgKiBkcHI7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLnVQeFNjYWxlLnZhbHVlID1cbiAgICAgICAgMSAvICgoZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCB8fCAxKSAqIDAuMSAqIFNDQUxFKTtcbiAgICB9O1xuICAgIGNvbnN0IHJvID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZSk7XG4gICAgcm8ub2JzZXJ2ZShjb250YWluZXIpO1xuICAgIHJlc2l6ZSgpO1xuXG4gICAgY29uc3Qgcm90QnVmID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICBjb25zdCBzZXRNYXQzRnJvbUV1bGVyID0gKFxuICAgICAgeWF3WTogbnVtYmVyLFxuICAgICAgcGl0Y2hYOiBudW1iZXIsXG4gICAgICByb2xsWjogbnVtYmVyLFxuICAgICAgb3V0OiBGbG9hdDMyQXJyYXlcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IGN5ID0gTWF0aC5jb3MoeWF3WSksXG4gICAgICAgIHN5ID0gTWF0aC5zaW4oeWF3WSk7XG4gICAgICBjb25zdCBjeCA9IE1hdGguY29zKHBpdGNoWCksXG4gICAgICAgIHN4ID0gTWF0aC5zaW4ocGl0Y2hYKTtcbiAgICAgIGNvbnN0IGN6ID0gTWF0aC5jb3Mocm9sbFopLFxuICAgICAgICBzeiA9IE1hdGguc2luKHJvbGxaKTtcbiAgICAgIGNvbnN0IHIwMCA9IGN5ICogY3ogKyBzeSAqIHN4ICogc3o7XG4gICAgICBjb25zdCByMDEgPSAtY3kgKiBzeiArIHN5ICogc3ggKiBjejtcbiAgICAgIGNvbnN0IHIwMiA9IHN5ICogY3g7XG5cbiAgICAgIGNvbnN0IHIxMCA9IGN4ICogc3o7XG4gICAgICBjb25zdCByMTEgPSBjeCAqIGN6O1xuICAgICAgY29uc3QgcjEyID0gLXN4O1xuXG4gICAgICBjb25zdCByMjAgPSAtc3kgKiBjeiArIGN5ICogc3ggKiBzejtcbiAgICAgIGNvbnN0IHIyMSA9IHN5ICogc3ogKyBjeSAqIHN4ICogY3o7XG4gICAgICBjb25zdCByMjIgPSBjeSAqIGN4O1xuXG4gICAgICBvdXRbMF0gPSByMDA7XG4gICAgICBvdXRbMV0gPSByMTA7XG4gICAgICBvdXRbMl0gPSByMjA7XG4gICAgICBvdXRbM10gPSByMDE7XG4gICAgICBvdXRbNF0gPSByMTE7XG4gICAgICBvdXRbNV0gPSByMjE7XG4gICAgICBvdXRbNl0gPSByMDI7XG4gICAgICBvdXRbN10gPSByMTI7XG4gICAgICBvdXRbOF0gPSByMjI7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBjb25zdCBOT0lTRV9JU19aRVJPID0gTk9JU0UgPCAxZS02O1xuICAgIGxldCByYWYgPSAwO1xuICAgIGNvbnN0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RhcnRSQUYgPSAoKSA9PiB7XG4gICAgICBpZiAocmFmKSByZXR1cm47XG4gICAgICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0b3BSQUYgPSAoKSA9PiB7XG4gICAgICBpZiAoIXJhZikgcmV0dXJuO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgIHJhZiA9IDA7XG4gICAgfTtcblxuICAgIGNvbnN0IHJuZCA9ICgpID0+IE1hdGgucmFuZG9tKCk7XG4gICAgY29uc3Qgd1ggPSAoMC4zICsgcm5kKCkgKiAwLjYpICogUlNYO1xuICAgIGNvbnN0IHdZID0gKDAuMiArIHJuZCgpICogMC43KSAqIFJTWTtcbiAgICBjb25zdCB3WiA9ICgwLjEgKyBybmQoKSAqIDAuNSkgKiBSU1o7XG4gICAgY29uc3QgcGhYID0gcm5kKCkgKiBNYXRoLlBJICogMjtcbiAgICBjb25zdCBwaFogPSBybmQoKSAqIE1hdGguUEkgKiAyO1xuXG4gICAgbGV0IHlhdyA9IDAsXG4gICAgICBwaXRjaCA9IDAsXG4gICAgICByb2xsID0gMDtcbiAgICBsZXQgdGFyZ2V0WWF3ID0gMCxcbiAgICAgIHRhcmdldFBpdGNoID0gMDtcbiAgICBjb25zdCBsZXJwID0gKGE6IG51bWJlciwgYjogbnVtYmVyLCB0OiBudW1iZXIpID0+IGEgKyAoYiAtIGEpICogdDtcblxuICAgIGNvbnN0IHBvaW50ZXIgPSB7IHg6IDAsIHk6IDAsIGluc2lkZTogdHJ1ZSB9O1xuICAgIGNvbnN0IG9uTW92ZSA9IChlOiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHd3ID0gTWF0aC5tYXgoMSwgd2luZG93LmlubmVyV2lkdGgpO1xuICAgICAgY29uc3Qgd2ggPSBNYXRoLm1heCgxLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgY29uc3QgY3ggPSB3dyAqIDAuNTtcbiAgICAgIGNvbnN0IGN5ID0gd2ggKiAwLjU7XG4gICAgICBjb25zdCBueCA9IChlLmNsaWVudFggLSBjeCkgLyAod3cgKiAwLjUpO1xuICAgICAgY29uc3QgbnkgPSAoZS5jbGllbnRZIC0gY3kpIC8gKHdoICogMC41KTtcbiAgICAgIHBvaW50ZXIueCA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBueCkpO1xuICAgICAgcG9pbnRlci55ID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIG55KSk7XG4gICAgICBwb2ludGVyLmluc2lkZSA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBvbkxlYXZlID0gKCkgPT4ge1xuICAgICAgcG9pbnRlci5pbnNpZGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQmx1ciA9ICgpID0+IHtcbiAgICAgIHBvaW50ZXIuaW5zaWRlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCBvblBvaW50ZXJNb3ZlOiAoKGU6IFBvaW50ZXJFdmVudCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJob3ZlclwiKSB7XG4gICAgICBvblBvaW50ZXJNb3ZlID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgICBvbk1vdmUoZSk7XG4gICAgICAgIHN0YXJ0UkFGKCk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25MZWF2ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgb25CbHVyKTtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMudVVzZUJhc2VXb2JibGUudmFsdWUgPSAwO1xuICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCIzZHJvdGF0ZVwiKSB7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLnVVc2VCYXNlV29iYmxlLnZhbHVlID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51VXNlQmFzZVdvYmJsZS52YWx1ZSA9IDE7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyID0gKHQ6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgdGltZSA9ICh0IC0gdDApICogMC4wMDE7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLmlUaW1lLnZhbHVlID0gdGltZTtcblxuICAgICAgbGV0IGNvbnRpbnVlUkFGID0gdHJ1ZTtcblxuICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwiaG92ZXJcIikge1xuICAgICAgICBjb25zdCBtYXhQaXRjaCA9IDAuNiAqIEhPVlNUUjtcbiAgICAgICAgY29uc3QgbWF4WWF3ID0gMC42ICogSE9WU1RSO1xuICAgICAgICB0YXJnZXRZYXcgPSAocG9pbnRlci5pbnNpZGUgPyAtcG9pbnRlci54IDogMCkgKiBtYXhZYXc7XG4gICAgICAgIHRhcmdldFBpdGNoID0gKHBvaW50ZXIuaW5zaWRlID8gcG9pbnRlci55IDogMCkgKiBtYXhQaXRjaDtcbiAgICAgICAgY29uc3QgcHJldllhdyA9IHlhdztcbiAgICAgICAgY29uc3QgcHJldlBpdGNoID0gcGl0Y2g7XG4gICAgICAgIGNvbnN0IHByZXZSb2xsID0gcm9sbDtcbiAgICAgICAgeWF3ID0gbGVycChwcmV2WWF3LCB0YXJnZXRZYXcsIElORVJUKTtcbiAgICAgICAgcGl0Y2ggPSBsZXJwKHByZXZQaXRjaCwgdGFyZ2V0UGl0Y2gsIElORVJUKTtcbiAgICAgICAgcm9sbCA9IGxlcnAocHJldlJvbGwsIDAsIDAuMSk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybXMudVJvdC52YWx1ZSA9IHNldE1hdDNGcm9tRXVsZXIoXG4gICAgICAgICAgeWF3LFxuICAgICAgICAgIHBpdGNoLFxuICAgICAgICAgIHJvbGwsXG4gICAgICAgICAgcm90QnVmXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKE5PSVNFX0lTX1pFUk8pIHtcbiAgICAgICAgICBjb25zdCBzZXR0bGVkID1cbiAgICAgICAgICAgIE1hdGguYWJzKHlhdyAtIHRhcmdldFlhdykgPCAxZS00ICYmXG4gICAgICAgICAgICBNYXRoLmFicyhwaXRjaCAtIHRhcmdldFBpdGNoKSA8IDFlLTQgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHJvbGwpIDwgMWUtNDtcbiAgICAgICAgICBpZiAoc2V0dGxlZCkgY29udGludWVSQUYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbmltYXRpb25UeXBlID09PSBcIjNkcm90YXRlXCIpIHtcbiAgICAgICAgY29uc3QgdFNjYWxlZCA9IHRpbWUgKiBUUztcbiAgICAgICAgeWF3ID0gdFNjYWxlZCAqIHdZO1xuICAgICAgICBwaXRjaCA9IE1hdGguc2luKHRTY2FsZWQgKiB3WCArIHBoWCkgKiAwLjY7XG4gICAgICAgIHJvbGwgPSBNYXRoLnNpbih0U2NhbGVkICogd1ogKyBwaFopICogMC41O1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm1zLnVSb3QudmFsdWUgPSBzZXRNYXQzRnJvbUV1bGVyKFxuICAgICAgICAgIHlhdyxcbiAgICAgICAgICBwaXRjaCxcbiAgICAgICAgICByb2xsLFxuICAgICAgICAgIHJvdEJ1ZlxuICAgICAgICApO1xuICAgICAgICBpZiAoVFMgPCAxZS02KSBjb250aW51ZVJBRiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm90QnVmWzBdID0gMTtcbiAgICAgICAgcm90QnVmWzFdID0gMDtcbiAgICAgICAgcm90QnVmWzJdID0gMDtcbiAgICAgICAgcm90QnVmWzNdID0gMDtcbiAgICAgICAgcm90QnVmWzRdID0gMTtcbiAgICAgICAgcm90QnVmWzVdID0gMDtcbiAgICAgICAgcm90QnVmWzZdID0gMDtcbiAgICAgICAgcm90QnVmWzddID0gMDtcbiAgICAgICAgcm90QnVmWzhdID0gMTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtcy51Um90LnZhbHVlID0gcm90QnVmO1xuICAgICAgICBpZiAoVFMgPCAxZS02KSBjb250aW51ZVJBRiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5yZW5kZXIoeyBzY2VuZTogbWVzaCB9KTtcbiAgICAgIGlmIChjb250aW51ZVJBRikge1xuICAgICAgICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhZiA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGludGVyZmFjZSBQcmlzbUNvbnRhaW5lciBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgIF9fcHJpc21JTz86IEludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIH1cblxuICAgIGlmIChzdXNwZW5kV2hlbk9mZnNjcmVlbikge1xuICAgICAgY29uc3QgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgY29uc3QgdmlzID0gZW50cmllcy5zb21lKChlKSA9PiBlLmlzSW50ZXJzZWN0aW5nKTtcbiAgICAgICAgaWYgKHZpcykgc3RhcnRSQUYoKTtcbiAgICAgICAgZWxzZSBzdG9wUkFGKCk7XG4gICAgICB9KTtcbiAgICAgIGlvLm9ic2VydmUoY29udGFpbmVyKTtcbiAgICAgIHN0YXJ0UkFGKCk7XG4gICAgICAoY29udGFpbmVyIGFzIFByaXNtQ29udGFpbmVyKS5fX3ByaXNtSU8gPSBpbztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRSQUYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcFJBRigpO1xuICAgICAgcm8uZGlzY29ubmVjdCgpO1xuICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwiaG92ZXJcIikge1xuICAgICAgICBpZiAob25Qb2ludGVyTW92ZSlcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwicG9pbnRlcm1vdmVcIixcbiAgICAgICAgICAgIG9uUG9pbnRlck1vdmUgYXMgRXZlbnRMaXN0ZW5lclxuICAgICAgICAgICk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBvbkxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG9uQmx1cik7XG4gICAgICB9XG4gICAgICBpZiAoc3VzcGVuZFdoZW5PZmZzY3JlZW4pIHtcbiAgICAgICAgY29uc3QgaW8gPSAoY29udGFpbmVyIGFzIFByaXNtQ29udGFpbmVyKS5fX3ByaXNtSU8gYXNcbiAgICAgICAgICB8IEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpbykgaW8uZGlzY29ubmVjdCgpO1xuICAgICAgICBkZWxldGUgKGNvbnRhaW5lciBhcyBQcmlzbUNvbnRhaW5lcikuX19wcmlzbUlPO1xuICAgICAgfVxuICAgICAgaWYgKGdsLmNhbnZhcy5wYXJlbnRFbGVtZW50ID09PSBjb250YWluZXIpXG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChnbC5jYW52YXMpO1xuICAgIH07XG4gIH0sIFtcbiAgICBnbG93LFxuICAgIG5vaXNlLFxuICAgIHNjYWxlLFxuICAgIGJsb29tLFxuICAgIGhlaWdodCxcbiAgICBpbmVydGlhLFxuICAgIGh1ZVNoaWZ0LFxuICAgIGJhc2VXaWR0aCxcbiAgICBvZmZzZXQ/LngsXG4gICAgb2Zmc2V0Py55LFxuICAgIHRpbWVTY2FsZSxcbiAgICB0cmFuc3BhcmVudCxcbiAgICBhbmltYXRpb25UeXBlLFxuICAgIGhvdmVyU3RyZW5ndGgsXG4gICAgY29sb3JGcmVxdWVuY3ksXG4gICAgc3VzcGVuZFdoZW5PZmZzY3JlZW4sXG4gIF0pO1xuXG4gIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgYWJzb2x1dGVcIiByZWY9e2NvbnRhaW5lclJlZn0gLz47XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiTWVzaCIsIlByb2dyYW0iLCJSZW5kZXJlciIsIlRyaWFuZ2xlIiwiUHJpc20iLCJnbG93IiwiYmxvb20iLCJub2lzZSIsInNjYWxlIiwiaGVpZ2h0IiwiaHVlU2hpZnQiLCJpbmVydGlhIiwiYmFzZVdpZHRoIiwidGltZVNjYWxlIiwiaG92ZXJTdHJlbmd0aCIsInRyYW5zcGFyZW50IiwiY29sb3JGcmVxdWVuY3kiLCJvZmZzZXQiLCJ4IiwieSIsImFuaW1hdGlvblR5cGUiLCJzdXNwZW5kV2hlbk9mZnNjcmVlbiIsImNvbnRhaW5lclJlZiIsImNvbnRhaW5lciIsImN1cnJlbnQiLCJIIiwiTWF0aCIsIm1heCIsIkJXIiwiQkFTRV9IQUxGIiwiR0xPVyIsIk5PSVNFIiwib2ZmWCIsIm9mZlkiLCJTQVQiLCJTQ0FMRSIsIkhVRSIsIkNGUkVRIiwiQkxPT00iLCJSU1giLCJSU1kiLCJSU1oiLCJUUyIsIkhPVlNUUiIsIklORVJUIiwibWluIiwiZHByIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJlbmRlcmVyIiwiYWxwaGEiLCJhbnRpYWxpYXMiLCJnbCIsImRpc2FibGUiLCJERVBUSF9URVNUIiwiQ1VMTF9GQUNFIiwiQkxFTkQiLCJPYmplY3QiLCJhc3NpZ24iLCJjYW52YXMiLCJzdHlsZSIsInBvc2l0aW9uIiwiaW5zZXQiLCJ3aWR0aCIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInZlcnRleCIsImZyYWdtZW50IiwiZ2VvbWV0cnkiLCJpUmVzQnVmIiwiRmxvYXQzMkFycmF5Iiwib2Zmc2V0UHhCdWYiLCJwcm9ncmFtIiwidW5pZm9ybXMiLCJpUmVzb2x1dGlvbiIsInZhbHVlIiwiaVRpbWUiLCJ1SGVpZ2h0IiwidUJhc2VIYWxmIiwidVVzZUJhc2VXb2JibGUiLCJ1Um90IiwidUdsb3ciLCJ1T2Zmc2V0UHgiLCJ1Tm9pc2UiLCJ1U2F0dXJhdGlvbiIsInVTY2FsZSIsInVIdWVTaGlmdCIsInVDb2xvckZyZXEiLCJ1Qmxvb20iLCJ1Q2VudGVyU2hpZnQiLCJ1SW52QmFzZUhhbGYiLCJ1SW52SGVpZ2h0IiwidU1pbkF4aXMiLCJ1UHhTY2FsZSIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJ1VGltZVNjYWxlIiwibWVzaCIsInJlc2l6ZSIsInciLCJjbGllbnRXaWR0aCIsImgiLCJjbGllbnRIZWlnaHQiLCJzZXRTaXplIiwiZHJhd2luZ0J1ZmZlcldpZHRoIiwicm8iLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJyb3RCdWYiLCJzZXRNYXQzRnJvbUV1bGVyIiwieWF3WSIsInBpdGNoWCIsInJvbGxaIiwib3V0IiwiY3kiLCJjb3MiLCJzeSIsInNpbiIsImN4Iiwic3giLCJjeiIsInN6IiwicjAwIiwicjAxIiwicjAyIiwicjEwIiwicjExIiwicjEyIiwicjIwIiwicjIxIiwicjIyIiwiTk9JU0VfSVNfWkVSTyIsInJhZiIsInQwIiwicGVyZm9ybWFuY2UiLCJub3ciLCJzdGFydFJBRiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbmRlciIsInN0b3BSQUYiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJuZCIsInJhbmRvbSIsIndYIiwid1kiLCJ3WiIsInBoWCIsIlBJIiwicGhaIiwieWF3IiwicGl0Y2giLCJyb2xsIiwidGFyZ2V0WWF3IiwidGFyZ2V0UGl0Y2giLCJsZXJwIiwiYSIsImIiLCJ0IiwicG9pbnRlciIsImluc2lkZSIsIm9uTW92ZSIsImUiLCJ3dyIsImlubmVyV2lkdGgiLCJ3aCIsImlubmVySGVpZ2h0IiwibngiLCJjbGllbnRYIiwibnkiLCJjbGllbnRZIiwib25MZWF2ZSIsIm9uQmx1ciIsIm9uUG9pbnRlck1vdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInRpbWUiLCJjb250aW51ZVJBRiIsIm1heFBpdGNoIiwibWF4WWF3IiwicHJldllhdyIsInByZXZQaXRjaCIsInByZXZSb2xsIiwic2V0dGxlZCIsImFicyIsInRTY2FsZWQiLCJzY2VuZSIsImlvIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwidmlzIiwic29tZSIsImlzSW50ZXJzZWN0aW5nIiwiX19wcmlzbUlPIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJlbnRFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/ui/prisma-background/index.tsx\n"));

/***/ })

});